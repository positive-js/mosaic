## API Report File for "mosaic"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AfterContentChecked } from '@angular/core';
import { AfterContentInit } from '@angular/core';
import { AfterViewInit } from '@angular/core';
import { BehaviorSubject } from 'rxjs';
import { CanDisable } from '@ptsecurity/mosaic/core';
import { CanDisableCtor } from '@ptsecurity/mosaic/core';
import { ChangeDetectorRef } from '@angular/core';
import { Clipboard as Clipboard_2 } from '@angular/cdk/clipboard';
import { CollectionViewer } from '@angular/cdk/collections';
import { ControlValueAccessor } from '@angular/forms';
import { DataSource } from '@angular/cdk/collections';
import { Directionality } from '@angular/cdk/bidi';
import { ElementRef } from '@angular/core';
import { EventEmitter } from '@angular/core';
import { FocusKeyManager } from '@ptsecurity/cdk/a11y';
import { FocusOrigin } from '@angular/cdk/a11y';
import { HasTabIndex } from '@ptsecurity/mosaic/core';
import * as i0 from '@angular/core';
import * as i10 from '@ptsecurity/mosaic/core';
import * as i9 from '@angular/common';
import { IFocusableOption } from '@ptsecurity/cdk/a11y';
import { InjectionToken } from '@angular/core';
import { IterableDiffer } from '@angular/core';
import { IterableDiffers } from '@angular/core';
import { McDropdownTrigger } from '@ptsecurity/mosaic/dropdown';
import { McOptionActionComponent } from '@ptsecurity/mosaic/core';
import { McPseudoCheckbox } from '@ptsecurity/mosaic/core';
import { McTooltipTrigger } from '@ptsecurity/mosaic/tooltip';
import { MultipleMode } from '@ptsecurity/mosaic/core';
import { NgZone } from '@angular/core';
import { Observable } from 'rxjs';
import { OnDestroy } from '@angular/core';
import { OnInit } from '@angular/core';
import { QueryList } from '@angular/core';
import { Renderer2 } from '@angular/core';
import { SelectionChange } from '@angular/cdk/collections';
import { SelectionModel } from '@angular/cdk/collections';
import { Subject } from 'rxjs';
import { TemplateRef } from '@angular/core';
import { TrackByFunction } from '@angular/core';
import { ViewContainerRef } from '@angular/core';

// @public
export abstract class BaseTreeControl<T> implements TreeControl<T> {
    collapse(dataNode: T): void;
    collapseAll(): void;
    collapseDescendants(dataNode: T): void;
    // (undocumented)
    dataNodes: T[];
    expand(dataNode: T): void;
    abstract expandAll(): void;
    expandDescendants(dataNode: T): void;
    expansionModel: SelectionModel<T>;
    // (undocumented)
    filterModel: SelectionModel<T>;
    // (undocumented)
    filterValue: BehaviorSubject<string>;
    getChildren: (dataNode: T) => Observable<T[]>;
    abstract getDescendants(dataNode: T): T[];
    getLevel: (dataNode: T) => number;
    isExpandable: (dataNode: T) => boolean;
    isExpanded(dataNode: T): boolean;
    toggle(dataNode: T): void;
    toggleDescendants(dataNode: T): void;
}

// @public (undocumented)
export function defaultCompareValues(firstValue: any, secondValue: any): boolean;

// @public (undocumented)
export function defaultCompareViewValues(firstViewValue: any, secondViewValue: any): boolean;

// @public
export class FlatTreeControl<T> extends BaseTreeControl<T> {
    constructor(getLevel: (dataNode: T) => number, isExpandable: (dataNode: T) => boolean,
    getValue: (dataNode: any) => any,
    getViewValue: (dataNode: any) => string,
    compareValues?: (firstValue: any, secondValue: any) => boolean,
    compareViewValues?: (firstViewValue: any, secondViewValue: any) => boolean);
    compareValues: (firstValue: any, secondValue: any) => boolean;
    compareViewValues: (firstViewValue: any, secondViewValue: any) => boolean;
    expandAll(): void;
    // (undocumented)
    expandedItemsBeforeFiltration: T[];
    // (undocumented)
    filterNodes(value: string): void;
    getDescendants(dataNode: T): T[];
    // (undocumented)
    getLevel: (dataNode: T) => number;
    // (undocumented)
    getParents(node: any, result: T[]): T[];
    getValue: (dataNode: any) => any;
    getViewValue: (dataNode: any) => string;
    // (undocumented)
    hasValue(value: string): T | undefined;
    // (undocumented)
    isExpandable: (dataNode: T) => boolean;
}

// @public (undocumented)
export const MC_SELECTION_TREE_VALUE_ACCESSOR: any;

// @public
export const MC_TREE_OPTION_PARENT_COMPONENT: InjectionToken<any>;

// @public (undocumented)
export class McTree extends McTreeBase<any> {
    // (undocumented)
    static ɵcmp: i0.ɵɵComponentDeclaration<McTree, "mc-tree", ["mcTree"], {}, {}, never, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<McTree, never>;
}

// @public (undocumented)
export class McTreeBase<T> implements AfterContentChecked, CollectionViewer, OnDestroy, OnInit {
    constructor(differs: IterableDiffers, changeDetectorRef: ChangeDetectorRef);
    // (undocumented)
    protected changeDetectorRef: ChangeDetectorRef;
    protected dataDiffer: IterableDiffer<T>;
    get dataSource(): DataSource<T> | Observable<T[]> | T[];
    set dataSource(dataSource: DataSource<T> | Observable<T[]> | T[]);
    // (undocumented)
    protected differs: IterableDiffers;
    getNodeDef(data: T, i: number): McTreeNodeDef<T>;
    insertNode(nodeData: T, index: number, viewContainer?: ViewContainerRef, parentData?: T): void;
    // (undocumented)
    ngAfterContentChecked(): void;
    // (undocumented)
    ngOnDestroy(): void;
    // (undocumented)
    ngOnInit(): void;
    nodeDefs: QueryList<McTreeNodeDef<T>>;
    // (undocumented)
    nodeOutlet: McTreeNodeOutlet;
    renderNodeChanges(data: T[] | ReadonlyArray<T>, dataDiffer?: IterableDiffer<T>, viewContainer?: ViewContainerRef, parentData?: T): void;
    trackBy: TrackByFunction<T>;
    // (undocumented)
    treeControl: TreeControl<T>;
    viewChange: BehaviorSubject<{
        start: number;
        end: number;
    }>;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<McTreeBase<any>, never, never, { "treeControl": "treeControl"; "trackBy": "trackBy"; "dataSource": "dataSource"; }, {}, ["nodeDefs"]>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<McTreeBase<any>, never>;
}

// @public (undocumented)
export class McTreeCopyEvent<T> {
    constructor(source: McTreeSelection, option: T);
    // (undocumented)
    option: T;
    // (undocumented)
    source: McTreeSelection;
}

// @public
export class McTreeFlatDataSource<T, F> extends DataSource<F> {
    constructor(treeControl: FlatTreeControl<F>, treeFlattener: McTreeFlattener<T, F>, initialData?: T[]);
    // (undocumented)
    connect(collectionViewer: CollectionViewer): Observable<F[]>;
    // (undocumented)
    get data(): T[];
    set data(value: T[]);
    // (undocumented)
    disconnect(): void;
    // (undocumented)
    expandedData: BehaviorSubject<F[]>;
    // (undocumented)
    expansionHandler(_change: SelectionChange<F>): F[];
    // (undocumented)
    filteredData: BehaviorSubject<F[]>;
    // (undocumented)
    filterHandler(): F[];
    // (undocumented)
    flattenedData: BehaviorSubject<F[]>;
}

// @public
export class McTreeFlattener<T, F> {
    constructor(transformFunction: (node: T, level: number, parent: F | null) => F, getLevel: (node: F) => number, isExpandable: (node: F) => boolean, getChildren: (node: T) => Observable<T[]> | T[] | undefined | null);
    expandFlattenedNodes(nodes: F[], treeControl: TreeControl<F>): F[];
    // (undocumented)
    flattenChildren(children: T[], level: number, resultNodes: F[], parent: F | null): void;
    // (undocumented)
    flattenNode(node: T, level: number, resultNodes: F[], parent: F | null): F[];
    flattenNodes(structuredData: T[]): F[];
    // (undocumented)
    getChildren: (node: T) => Observable<T[]> | T[] | undefined | null;
    // (undocumented)
    getLevel: (node: F) => number;
    // (undocumented)
    isExpandable: (node: F) => boolean;
    // (undocumented)
    transformFunction: (node: T, level: number, parent: F | null) => F;
}

// @public (undocumented)
export class McTreeModule {
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<McTreeModule, never>;
    // (undocumented)
    static ɵinj: i0.ɵɵInjectorDeclaration<McTreeModule>;
    // Warning: (ae-forgotten-export) The symbol "i1" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "i2" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "i3" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "i4" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "i5" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "i6" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "i7" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "i8" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    static ɵmod: i0.ɵɵNgModuleDeclaration<McTreeModule, [typeof i1.McTreeNodeOutlet, typeof i2.McTreeNodeDef, typeof i3.McTreeNode, typeof i4.McTreeNodePadding, typeof i5.McTree, typeof i6.McTreeSelection, typeof i7.McTreeOption, typeof i8.McTreeNodeToggleComponent, typeof i8.McTreeNodeToggleDirective], [typeof i9.CommonModule, typeof i10.McPseudoCheckboxModule], [typeof i1.McTreeNodeOutlet, typeof i2.McTreeNodeDef, typeof i3.McTreeNode, typeof i4.McTreeNodePadding, typeof i5.McTree, typeof i6.McTreeSelection, typeof i7.McTreeOption, typeof i8.McTreeNodeToggleComponent, typeof i8.McTreeNodeToggleDirective]>;
}

// @public (undocumented)
export class McTreeNavigationChange<T> {
    constructor(source: McTreeSelection, option: T);
    // (undocumented)
    option: T;
    // (undocumented)
    source: McTreeSelection;
}

// @public
export class McTreeNestedDataSource<T> extends DataSource<T> {
    // (undocumented)
    connect(collectionViewer: CollectionViewer): Observable<T[]>;
    // (undocumented)
    get data(): T[];
    set data(value: T[]);
    // (undocumented)
    disconnect(): void;
}

// @public (undocumented)
export class McTreeNode<T> implements IFocusableOption, OnDestroy {
    constructor(elementRef: ElementRef, tree: McTreeBase<T>);
    // (undocumented)
    get data(): T;
    set data(value: T);
    // (undocumented)
    protected destroyed: Subject<void>;
    // (undocumented)
    protected elementRef: ElementRef;
    // (undocumented)
    focus(): void;
    // (undocumented)
    get isExpanded(): boolean;
    // (undocumented)
    get level(): number;
    static mostRecentTreeNode: McTreeNode<any> | null;
    // (undocumented)
    ngOnDestroy(): void;
    // (undocumented)
    tree: McTreeBase<T>;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<McTreeNode<any>, "mc-tree-node", ["mcTreeNode"], {}, {}, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<McTreeNode<any>, never>;
}

// @public
export class McTreeNodeDef<T> {
    constructor(template: TemplateRef<any>);
    // (undocumented)
    data: T;
    // (undocumented)
    template: TemplateRef<any>;
    when: (index: number, nodeData: T) => boolean;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<McTreeNodeDef<any>, "[mcTreeNodeDef]", never, { "when": "mcTreeNodeDefWhen"; "data": "mcTreeNode"; }, {}, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<McTreeNodeDef<any>, never>;
}

// @public (undocumented)
export class McTreeNodeOutlet {
    constructor(viewContainer: ViewContainerRef, changeDetectorRef: ChangeDetectorRef);
    // (undocumented)
    changeDetectorRef: ChangeDetectorRef;
    // (undocumented)
    viewContainer: ViewContainerRef;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<McTreeNodeOutlet, "[mcTreeNodeOutlet]", never, {}, {}, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<McTreeNodeOutlet, never>;
}

// @public
export class McTreeNodeOutletContext<T> {
    $implicit: T;
    constructor(data: T);
    count?: number;
    index?: number;
    level: number;
}

// @public (undocumented)
export class McTreeNodePadding<T> implements OnDestroy, AfterViewInit {
    constructor(treeNode: McTreeNode<T>, tree: McTreeBase<T>, renderer: Renderer2, element: ElementRef<HTMLElement>, option: McTreeOption, dir: Directionality);
    // (undocumented)
    baseLeftPadding: number;
    // (undocumented)
    iconWidth: number;
    // (undocumented)
    get indent(): number | string;
    set indent(indent: number | string);
    indentUnits: string;
    // (undocumented)
    get leftPadding(): number;
    // (undocumented)
    get level(): number;
    set level(value: number);
    // (undocumented)
    ngAfterViewInit(): void;
    // (undocumented)
    ngOnDestroy(): void;
    // (undocumented)
    paddingIndent(): string | null;
    // (undocumented)
    protected tree: McTreeBase<T>;
    // (undocumented)
    protected treeNode: McTreeNode<T>;
    // (undocumented)
    withIcon: boolean;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<McTreeNodePadding<any>, "[mcTreeNodePadding]", ["mcTreeNodePadding"], { "indent": "mcTreeNodePaddingIndent"; }, {}, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<McTreeNodePadding<any>, [null, null, null, null, null, { optional: true; }]>;
}

// @public (undocumented)
export class McTreeNodeToggleBase {
}

// @public
export class McTreeNodeToggleBaseDirective<T> extends McTreeNodeToggleMixinBase implements CanDisable {
    constructor(tree: McTreeBase<T>, treeNode: McTreeNode<T>);
    // (undocumented)
    get iconState(): boolean;
    // (undocumented)
    node: T;
    // (undocumented)
    get recursive(): boolean;
    set recursive(value: any);
    // (undocumented)
    toggle(event: Event): void;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<McTreeNodeToggleBaseDirective<any>, never, never, { "node": "node"; "recursive": "mcTreeNodeToggleRecursive"; }, {}, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<McTreeNodeToggleBaseDirective<any>, never>;
}

// @public (undocumented)
export class McTreeNodeToggleComponent<T> extends McTreeNodeToggleBaseDirective<T> {
    // (undocumented)
    static ɵcmp: i0.ɵɵComponentDeclaration<McTreeNodeToggleComponent<any>, "mc-tree-node-toggle", ["mcTreeNodeToggle"], { "disabled": "disabled"; }, {}, never, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<McTreeNodeToggleComponent<any>, never>;
}

// @public (undocumented)
export class McTreeNodeToggleDirective<T> extends McTreeNodeToggleBaseDirective<T> {
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<McTreeNodeToggleDirective<any>, "[mc-tree-node-toggle], [mcTreeNodeToggle]", ["mcTreeNodeToggle"], {}, {}, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<McTreeNodeToggleDirective<any>, never>;
}

// @public (undocumented)
export const McTreeNodeToggleMixinBase: CanDisableCtor & typeof McTreeNodeToggleBase;

// @public (undocumented)
export class McTreeOption extends McTreeNode<McTreeOption> implements AfterContentInit {
    constructor(elementRef: ElementRef, changeDetectorRef: ChangeDetectorRef, ngZone: NgZone, tree: any);
    // (undocumented)
    actionButton: McOptionActionComponent;
    // (undocumented)
    blur(): void;
    // (undocumented)
    deselect(): void;
    // (undocumented)
    get disabled(): any;
    set disabled(value: any);
    // (undocumented)
    dropdownTrigger: McDropdownTrigger;
    // (undocumented)
    emitSelectionChangeEvent(isUserInput?: boolean): void;
    // (undocumented)
    get externalPseudoCheckbox(): boolean;
    // (undocumented)
    focus(focusOrigin?: FocusOrigin): void;
    // (undocumented)
    getHeight(): number;
    // (undocumented)
    getHostElement(): HTMLElement;
    // (undocumented)
    hasFocus: boolean;
    // (undocumented)
    get id(): string;
    // (undocumented)
    get isExpandable(): boolean;
    // (undocumented)
    markForCheck(): void;
    // (undocumented)
    ngAfterContentInit(): void;
    // (undocumented)
    readonly onBlur: Subject<McTreeOptionEvent>;
    // (undocumented)
    readonly onFocus: Subject<McTreeOptionEvent>;
    // (undocumented)
    onKeydown($event: any): void;
    // (undocumented)
    readonly onSelectionChange: EventEmitter<McTreeOptionChange>;
    // (undocumented)
    pseudoCheckbox: McPseudoCheckbox;
    // (undocumented)
    select(setFocus?: boolean): void;
    // (undocumented)
    get selected(): boolean;
    set selected(value: boolean);
    // (undocumented)
    selectViaInteraction($event?: KeyboardEvent): void;
    // (undocumented)
    setSelected(selected: boolean): void;
    // (undocumented)
    get showCheckbox(): any;
    set showCheckbox(value: any);
    // (undocumented)
    toggle(): void;
    // (undocumented)
    toggleElement: McTreeNodeToggleDirective<McTreeOption>;
    // (undocumented)
    tooltipTrigger: McTooltipTrigger;
    // (undocumented)
    tree: any;
    // (undocumented)
    get value(): any;
    set value(value: any);
    // (undocumented)
    get viewValue(): string;
    // (undocumented)
    static ɵcmp: i0.ɵɵComponentDeclaration<McTreeOption, "mc-tree-option", ["mcTreeOption"], { "disabled": "disabled"; "showCheckbox": "showCheckbox"; }, { "onSelectionChange": "onSelectionChange"; }, ["toggleElement", "pseudoCheckbox", "actionButton", "tooltipTrigger", "dropdownTrigger"], ["mc-tree-node-toggle, [mc-tree-node-toggle], [mcTreeNodeToggle]", "mc-pseudo-checkbox", "mc-checkbox", "[mc-icon]", "mc-progress-spinner", "*", "mc-option-action"]>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<McTreeOption, never>;
}

// @public (undocumented)
export class McTreeOptionChange {
    constructor(source: McTreeOption, isUserInput?: boolean);
    // (undocumented)
    isUserInput: boolean;
    // (undocumented)
    source: McTreeOption;
}

// @public (undocumented)
export interface McTreeOptionEvent {
    // (undocumented)
    option: McTreeOption;
}

// @public (undocumented)
export class McTreeSelectAllEvent<T> {
    constructor(source: McTreeSelection, options: T[]);
    // (undocumented)
    options: T[];
    // (undocumented)
    source: McTreeSelection;
}

// @public (undocumented)
export class McTreeSelection extends McTreeBase<any> implements ControlValueAccessor, AfterContentInit, CanDisable, HasTabIndex {
    constructor(elementRef: ElementRef, differs: IterableDiffers, changeDetectorRef: ChangeDetectorRef, multiple: MultipleMode, clipboard: Clipboard_2);
    // (undocumented)
    get autoSelect(): boolean;
    set autoSelect(value: boolean);
    // (undocumented)
    blur(): void;
    // (undocumented)
    copyActiveOption(): void;
    // (undocumented)
    get disabled(): boolean;
    set disabled(rawValue: boolean);
    // (undocumented)
    emitChangeEvent(option: McTreeOption): void;
    // (undocumented)
    emitNavigationEvent(option: McTreeOption): void;
    // (undocumented)
    focus($event: any): void;
    // (undocumented)
    getItemHeight(): number;
    // (undocumented)
    getSelectedValues(): any[];
    // (undocumented)
    get isEmpty(): boolean;
    // (undocumented)
    keyManager: FocusKeyManager<McTreeOption>;
    // (undocumented)
    get multiple(): boolean;
    // (undocumented)
    multipleMode: MultipleMode | null;
    // (undocumented)
    readonly navigationChange: EventEmitter<McTreeNavigationChange<McTreeOption>>;
    // (undocumented)
    ngAfterContentInit(): void;
    // (undocumented)
    ngOnDestroy(): void;
    // (undocumented)
    nodeOutlet: McTreeNodeOutlet;
    // (undocumented)
    get noUnselectLast(): boolean;
    set noUnselectLast(value: boolean);
    onChange: (value: any) => void;
    // (undocumented)
    readonly onCopy: EventEmitter<McTreeCopyEvent<McTreeOption>>;
    // (undocumented)
    onKeyDown(event: KeyboardEvent): void;
    // (undocumented)
    readonly onSelectAll: EventEmitter<McTreeSelectAllEvent<McTreeOption>>;
    onTouched: () => void;
    // (undocumented)
    get optionBlurChanges(): Observable<McTreeOptionEvent>;
    // (undocumented)
    get optionFocusChanges(): Observable<McTreeOptionEvent>;
    // (undocumented)
    registerOnChange(fn: (value: any) => void): void;
    // (undocumented)
    registerOnTouched(fn: () => {}): void;
    // (undocumented)
    renderedOptions: QueryList<McTreeOption>;
    // (undocumented)
    renderNodeChanges(data: McTreeOption[], dataDiffer?: IterableDiffer<McTreeOption>, viewContainer?: ViewContainerRef, parentData?: McTreeOption): void;
    // (undocumented)
    resetFocusedItemOnBlur: boolean;
    // (undocumented)
    selectAllOptions(): void;
    // (undocumented)
    readonly selectionChange: EventEmitter<McTreeSelectionChange<McTreeOption>>;
    // Warning: (ae-forgotten-export) The symbol "SelectionModelOption" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    selectionModel: SelectionModel<SelectionModelOption>;
    setDisabledState(isDisabled: boolean): void;
    // (undocumented)
    setFocusedOption(option: McTreeOption): void;
    // (undocumented)
    setOptionsFromValues(values: any[]): void;
    // (undocumented)
    setSelectedOptions(option: McTreeOption): void;
    // (undocumented)
    setSelectedOptionsByClick(option: McTreeOption, shiftKey: boolean, ctrlKey: boolean): void;
    // (undocumented)
    setSelectedOptionsByKey(option: McTreeOption, shiftKey: boolean, ctrlKey: boolean): void;
    // (undocumented)
    get showCheckbox(): boolean;
    // (undocumented)
    get tabIndex(): any;
    set tabIndex(value: any);
    // (undocumented)
    toggleFocusedOption(): void;
    // (undocumented)
    treeControl: FlatTreeControl<any>;
    // (undocumented)
    unorderedOptions: QueryList<McTreeOption>;
    // (undocumented)
    updateScrollSize(): void;
    // (undocumented)
    userTabIndex: number | null;
    // (undocumented)
    writeValue(value: any): void;
    // (undocumented)
    static ɵcmp: i0.ɵɵComponentDeclaration<McTreeSelection, "mc-tree-selection", ["mcTreeSelection"], { "treeControl": "treeControl"; "autoSelect": "autoSelect"; "noUnselectLast": "noUnselectLast"; "disabled": "disabled"; "tabIndex": "tabIndex"; }, { "navigationChange": "navigationChange"; "selectionChange": "selectionChange"; "onSelectAll": "onSelectAll"; "onCopy": "onCopy"; }, ["unorderedOptions"], never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<McTreeSelection, [null, null, null, { attribute: "multiple"; }, { optional: true; }]>;
}

// @public (undocumented)
export class McTreeSelectionChange<T> {
    constructor(source: McTreeSelection, option: T);
    // (undocumented)
    option: T;
    // (undocumented)
    source: McTreeSelection;
}

// @public
export class NestedTreeControl<T> extends BaseTreeControl<T> {
    constructor(getChildren: (dataNode: T) => Observable<T[]>);
    expandAll(): void;
    // (undocumented)
    getChildren: (dataNode: T) => Observable<T[]>;
    getDescendants(dataNode: T): T[];
}

// @public
export interface TreeControl<T> {
    collapse(dataNode: T): void;
    collapseAll(): void;
    collapseDescendants(dataNode: T): void;
    dataNodes: T[];
    expand(dataNode: T): void;
    expandAll(): void;
    expandDescendants(dataNode: T): void;
    expansionModel: SelectionModel<T>;
    // (undocumented)
    filterModel: SelectionModel<T>;
    // (undocumented)
    filterValue: BehaviorSubject<string>;
    getChildren(dataNode: T): Observable<T[]>;
    getDescendants(dataNode: T): any[];
    getLevel(dataNode: T): number;
    isExpandable(dataNode: T): boolean;
    isExpanded(dataNode: T): boolean;
    toggle(dataNode: T): void;
    toggleDescendants(dataNode: T): void;
}

// (No @packageDocumentation comment for this package)

```
