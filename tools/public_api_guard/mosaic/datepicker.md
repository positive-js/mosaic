## API Report File for "components-srcs"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { _AbstractConstructor } from '@angular/material/core';
import { AbstractControl } from '@angular/forms';
import { AfterContentInit } from '@angular/core';
import { AfterViewChecked } from '@angular/core';
import { AfterViewInit } from '@angular/core';
import { AnimationTriggerMetadata } from '@angular/animations';
import { BooleanInput } from '@angular/cdk/coercion';
import { CanColor } from '@angular/material/core';
import { CanUpdateErrorState } from '@angular/material/core';
import { ChangeDetectorRef } from '@angular/core';
import { ComponentType } from '@angular/cdk/portal';
import { _Constructor } from '@angular/material/core';
import { ControlContainer } from '@angular/forms';
import { ControlValueAccessor } from '@angular/forms';
import { DateAdapter } from '@angular/material/core';
import { Directionality } from '@angular/cdk/bidi';
import { DoCheck } from '@angular/core';
import { ElementRef } from '@angular/core';
import { ErrorStateMatcher } from '@angular/material/core';
import { EventEmitter } from '@angular/core';
import { FactoryProvider } from '@angular/core';
import { FocusOrigin } from '@angular/cdk/a11y';
import { FormGroupDirective } from '@angular/forms';
import * as i0 from '@angular/core';
import * as i14 from '@angular/common';
import * as i15 from '@angular/material/button';
import * as i16 from '@angular/cdk/overlay';
import * as i17 from '@angular/cdk/a11y';
import * as i18 from '@angular/cdk/portal';
import * as i19 from '@angular/material/core';
import * as i20 from '@angular/cdk/scrolling';
import { InjectionToken } from '@angular/core';
import { Injector } from '@angular/core';
import { MatButton } from '@angular/material/button';
import { MatDateFormats } from '@angular/material/core';
import { MatFormField } from '@angular/material/form-field';
import { MatFormFieldControl } from '@angular/material/form-field';
import { NgControl } from '@angular/forms';
import { NgForm } from '@angular/forms';
import { NgZone } from '@angular/core';
import { Observable } from 'rxjs';
import { OnChanges } from '@angular/core';
import { OnDestroy } from '@angular/core';
import { OnInit } from '@angular/core';
import { Overlay } from '@angular/cdk/overlay';
import { Portal } from '@angular/cdk/portal';
import { ScrollStrategy } from '@angular/cdk/overlay';
import { SimpleChanges } from '@angular/core';
import { Subject } from 'rxjs';
import { TemplatePortal } from '@angular/cdk/portal';
import { TemplateRef } from '@angular/core';
import { ThemePalette } from '@angular/material/core';
import { ValidationErrors } from '@angular/forms';
import { Validator } from '@angular/forms';
import { ValidatorFn } from '@angular/forms';
import { ViewContainerRef } from '@angular/core';

// @public
export type DateFilterFn<D> = (date: D | null) => boolean;

// @public
export type DatepickerDropdownPositionX = 'start' | 'end';

// @public
export type DatepickerDropdownPositionY = 'above' | 'below';

// @public
export class DateRange<D> {
    constructor(
    start: D | null,
    end: D | null);
    readonly end: D | null;
    readonly start: D | null;
}

// @public
export interface DateSelectionModelChange<S> {
    oldValue?: S;
    selection: S;
    source: unknown;
}

// @public
export class DefaultMatCalendarRangeStrategy<D> implements MatDateRangeSelectionStrategy<D> {
    constructor(_dateAdapter: DateAdapter<D>);
    // (undocumented)
    createPreview(activeDate: D | null, currentRange: DateRange<D>): DateRange<D>;
    // (undocumented)
    selectionFinished(date: D, currentRange: DateRange<D>): DateRange<D>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<DefaultMatCalendarRangeStrategy<any>, never>;
    // (undocumented)
    static ɵprov: i0.ɵɵInjectableDeclaration<DefaultMatCalendarRangeStrategy<any>>;
}

// @public
export type ExtractDateTypeFromSelection<T> = T extends DateRange<infer D> ? D : NonNullable<T>;

// @public
function getActiveOffset<D>(dateAdapter: DateAdapter<D>, activeDate: D, minDate: D | null, maxDate: D | null): number;

// @public (undocumented)
function isSameMultiYearView<D>(dateAdapter: DateAdapter<D>, date1: D, date2: D, minDate: D | null, maxDate: D | null): boolean;

// @public
const MAT_DATE_RANGE_INPUT_PARENT: InjectionToken<MatDateRangeInputParent<unknown>>;

// @public
export const MAT_DATE_RANGE_SELECTION_STRATEGY: InjectionToken<MatDateRangeSelectionStrategy<any>>;

// @public
export const MAT_DATEPICKER_SCROLL_STRATEGY: InjectionToken<() => ScrollStrategy>;

// @public
export function MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY(overlay: Overlay): () => ScrollStrategy;

// @public
export const MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY_PROVIDER: {
    provide: InjectionToken<() => ScrollStrategy>;
    deps: (typeof Overlay)[];
    useFactory: typeof MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY;
};

// @public
export const MAT_DATEPICKER_VALIDATORS: any;

// @public
export const MAT_DATEPICKER_VALUE_ACCESSOR: any;

// @public
export function MAT_RANGE_DATE_SELECTION_MODEL_FACTORY(parent: MatSingleDateSelectionModel<unknown>, adapter: DateAdapter<unknown>): MatSingleDateSelectionModel<unknown>;

// @public
export const MAT_RANGE_DATE_SELECTION_MODEL_PROVIDER: FactoryProvider;

// @public
export function MAT_SINGLE_DATE_SELECTION_MODEL_FACTORY(parent: MatSingleDateSelectionModel<unknown>, adapter: DateAdapter<unknown>): MatSingleDateSelectionModel<unknown>;

// @public
export const MAT_SINGLE_DATE_SELECTION_MODEL_PROVIDER: FactoryProvider;

// @public
export class MatCalendar<D> implements AfterContentInit, AfterViewChecked, OnDestroy, OnChanges {
    constructor(_intl: MatDatepickerIntl, _dateAdapter: DateAdapter<D>, _dateFormats: MatDateFormats, _changeDetectorRef: ChangeDetectorRef);
    get activeDate(): D;
    set activeDate(value: D);
    _calendarHeaderPortal: Portal<any>;
    comparisonEnd: D | null;
    comparisonStart: D | null;
    get currentView(): MatCalendarView;
    set currentView(value: MatCalendarView);
    dateClass: MatCalendarCellClassFunction<D>;
    dateFilter: (date: D) => boolean;
    _dateSelected(event: MatCalendarUserEvent<D | null>): void;
    focusActiveCell(): void;
    _goToDateInView(date: D, view: 'month' | 'year' | 'multi-year'): void;
    headerComponent: ComponentType<any>;
    get maxDate(): D | null;
    set maxDate(value: D | null);
    get minDate(): D | null;
    set minDate(value: D | null);
    readonly monthSelected: EventEmitter<D>;
    _monthSelectedInYearView(normalizedMonth: D): void;
    monthView: MatMonthView<D>;
    multiYearView: MatMultiYearView<D>;
    // (undocumented)
    ngAfterContentInit(): void;
    // (undocumented)
    ngAfterViewChecked(): void;
    // (undocumented)
    ngOnChanges(changes: SimpleChanges): void;
    // (undocumented)
    ngOnDestroy(): void;
    get selected(): DateRange<D> | D | null;
    set selected(value: DateRange<D> | D | null);
    readonly selectedChange: EventEmitter<D | null>;
    get startAt(): D | null;
    set startAt(value: D | null);
    startView: MatCalendarView;
    readonly stateChanges: Subject<void>;
    updateTodaysDate(): void;
    readonly _userSelection: EventEmitter<MatCalendarUserEvent<D | null>>;
    readonly viewChanged: EventEmitter<MatCalendarView>;
    readonly yearSelected: EventEmitter<D>;
    _yearSelectedInMultiYearView(normalizedYear: D): void;
    yearView: MatYearView<D>;
    // (undocumented)
    static ɵcmp: i0.ɵɵComponentDeclaration<MatCalendar<any>, "mat-calendar", ["matCalendar"], { "headerComponent": "headerComponent"; "startAt": "startAt"; "startView": "startView"; "selected": "selected"; "minDate": "minDate"; "maxDate": "maxDate"; "dateFilter": "dateFilter"; "dateClass": "dateClass"; "comparisonStart": "comparisonStart"; "comparisonEnd": "comparisonEnd"; }, { "selectedChange": "selectedChange"; "yearSelected": "yearSelected"; "monthSelected": "monthSelected"; "viewChanged": "viewChanged"; "_userSelection": "_userSelection"; }, never, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatCalendar<any>, [null, { optional: true; }, { optional: true; }, null]>;
}

// @public
export class MatCalendarBody implements OnChanges, OnDestroy {
    constructor(_elementRef: ElementRef<HTMLElement>, _ngZone: NgZone);
    activeCell: number;
    cellAspectRatio: number;
    _cellClicked(cell: MatCalendarCell, event: MouseEvent): void;
    _cellPadding: string;
    _cellWidth: string;
    comparisonEnd: number | null;
    comparisonStart: number | null;
    endValue: number;
    _firstRowOffset: number;
    _focusActiveCell(movePreview?: boolean): void;
    _isActiveCell(rowIndex: number, colIndex: number): boolean;
    _isComparisonBridgeEnd(value: number, rowIndex: number, colIndex: number): boolean;
    _isComparisonBridgeStart(value: number, rowIndex: number, colIndex: number): boolean;
    _isComparisonEnd(value: number): boolean;
    _isComparisonIdentical(value: number): boolean;
    _isComparisonStart(value: number): boolean;
    _isInComparisonRange(value: number): boolean;
    _isInPreview(value: number): boolean;
    _isInRange(value: number): boolean;
    _isPreviewEnd(value: number): boolean;
    _isPreviewStart(value: number): boolean;
    isRange: boolean;
    _isRangeEnd(value: number): boolean;
    _isRangeStart(value: number): boolean;
    _isSelected(value: number): boolean;
    label: string;
    labelMinRequiredCells: number;
    // (undocumented)
    ngOnChanges(changes: SimpleChanges): void;
    // (undocumented)
    ngOnDestroy(): void;
    numCols: number;
    readonly previewChange: EventEmitter<MatCalendarUserEvent<MatCalendarCell<any> | null>>;
    previewEnd: number | null;
    previewStart: number | null;
    rows: MatCalendarCell[][];
    readonly selectedValueChange: EventEmitter<MatCalendarUserEvent<number>>;
    startValue: number;
    todayValue: number;
    // (undocumented)
    static ɵcmp: i0.ɵɵComponentDeclaration<MatCalendarBody, "[mat-calendar-body]", ["matCalendarBody"], { "label": "label"; "rows": "rows"; "todayValue": "todayValue"; "startValue": "startValue"; "endValue": "endValue"; "labelMinRequiredCells": "labelMinRequiredCells"; "numCols": "numCols"; "activeCell": "activeCell"; "isRange": "isRange"; "cellAspectRatio": "cellAspectRatio"; "comparisonStart": "comparisonStart"; "comparisonEnd": "comparisonEnd"; "previewStart": "previewStart"; "previewEnd": "previewEnd"; }, { "selectedValueChange": "selectedValueChange"; "previewChange": "previewChange"; }, never, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatCalendarBody, never>;
}

// @public
export class MatCalendarCell<D = any> {
    constructor(value: number, displayValue: string, ariaLabel: string, enabled: boolean, cssClasses?: MatCalendarCellCssClasses, compareValue?: number, rawValue?: D | undefined);
    // (undocumented)
    ariaLabel: string;
    // (undocumented)
    compareValue: number;
    // (undocumented)
    cssClasses: MatCalendarCellCssClasses;
    // (undocumented)
    displayValue: string;
    // (undocumented)
    enabled: boolean;
    // (undocumented)
    rawValue?: D | undefined;
    // (undocumented)
    value: number;
}

// @public
export type MatCalendarCellClassFunction<D> = (date: D, view: 'month' | 'year' | 'multi-year') => MatCalendarCellCssClasses;

// @public
export type MatCalendarCellCssClasses = string | string[] | Set<string> | {
    [key: string]: any;
};

// @public
export class MatCalendarHeader<D> {
    constructor(_intl: MatDatepickerIntl, calendar: MatCalendar<D>, _dateAdapter: DateAdapter<D>, _dateFormats: MatDateFormats, changeDetectorRef: ChangeDetectorRef);
    // (undocumented)
    _buttonDescriptionId: string;
    // (undocumented)
    calendar: MatCalendar<D>;
    currentPeriodClicked(): void;
    get nextButtonLabel(): string;
    nextClicked(): void;
    nextEnabled(): boolean;
    // (undocumented)
    get periodButtonLabel(): string;
    get periodButtonText(): string;
    get prevButtonLabel(): string;
    previousClicked(): void;
    previousEnabled(): boolean;
    // (undocumented)
    static ɵcmp: i0.ɵɵComponentDeclaration<MatCalendarHeader<any>, "mat-calendar-header", ["matCalendarHeader"], {}, {}, never, ["*"]>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatCalendarHeader<any>, [null, null, { optional: true; }, { optional: true; }, null]>;
}

// @public
export interface MatCalendarUserEvent<D> {
    // (undocumented)
    event: Event;
    // (undocumented)
    value: D;
}

// @public
export type MatCalendarView = 'month' | 'year' | 'multi-year';

// @public
export class MatDatepicker<D> extends MatDatepickerBase<MatDatepickerControl<D>, D | null, D> {
    // (undocumented)
    static ɵcmp: i0.ɵɵComponentDeclaration<MatDatepicker<any>, "mat-datepicker", ["matDatepicker"], {}, {}, never, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatDatepicker<any>, never>;
}

// @public
export class MatDatepickerActions implements AfterViewInit, OnDestroy {
    constructor(_datepicker: MatDatepickerBase<MatDatepickerControl<unknown>, unknown>, _viewContainerRef: ViewContainerRef);
    // (undocumented)
    ngAfterViewInit(): void;
    // (undocumented)
    ngOnDestroy(): void;
    // (undocumented)
    _template: TemplateRef<unknown>;
    // (undocumented)
    static ɵcmp: i0.ɵɵComponentDeclaration<MatDatepickerActions, "mat-datepicker-actions, mat-date-range-picker-actions", never, {}, {}, never, ["*"]>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatDatepickerActions, never>;
}

// @public
export const matDatepickerAnimations: {
    readonly transformPanel: AnimationTriggerMetadata;
    readonly fadeInCalendar: AnimationTriggerMetadata;
};

// @public
export class MatDatepickerApply {
    constructor(_datepicker: MatDatepickerBase<MatDatepickerControl<unknown>, unknown>);
    // (undocumented)
    _applySelection(): void;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<MatDatepickerApply, "[matDatepickerApply], [matDateRangePickerApply]", never, {}, {}, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatDatepickerApply, never>;
}

// @public
abstract class MatDatepickerBase<C extends MatDatepickerControl<D>, S, D = ExtractDateTypeFromSelection<S>> implements MatDatepickerPanel<C, S, D>, OnDestroy, OnChanges {
    constructor(_overlay: Overlay, _ngZone: NgZone, _viewContainerRef: ViewContainerRef, scrollStrategy: any, _dateAdapter: DateAdapter<D>, _dir: Directionality, _model: MatDateSelectionModel<S, D>);
    _applyPendingSelection(): void;
    calendarHeaderComponent: ComponentType<any>;
    close(): void;
    readonly closedStream: EventEmitter<void>;
    get color(): ThemePalette;
    set color(value: ThemePalette);
    // (undocumented)
    _color: ThemePalette;
    dateClass: MatCalendarCellClassFunction<D>;
    datepickerInput: C;
    get disabled(): boolean;
    set disabled(value: boolean);
    protected _forwardContentValues(instance: MatDatepickerContent<S, D>): void;
    // (undocumented)
    _getDateFilter(): DateFilterFn<D>;
    _getMaxDate(): D | null;
    _getMinDate(): D | null;
    id: string;
    readonly monthSelected: EventEmitter<D>;
    // (undocumented)
    static ngAcceptInputType_disabled: BooleanInput;
    // (undocumented)
    static ngAcceptInputType_opened: BooleanInput;
    // (undocumented)
    static ngAcceptInputType_restoreFocus: BooleanInput;
    // (undocumented)
    static ngAcceptInputType_touchUi: BooleanInput;
    // (undocumented)
    ngOnChanges(changes: SimpleChanges): void;
    // (undocumented)
    ngOnDestroy(): void;
    open(): void;
    get opened(): boolean;
    set opened(value: boolean);
    readonly openedStream: EventEmitter<void>;
    get panelClass(): string | string[];
    set panelClass(value: string | string[]);
    registerActions(portal: TemplatePortal): void;
    registerInput(input: C): MatDateSelectionModel<S, D>;
    removeActions(portal: TemplatePortal): void;
    get restoreFocus(): boolean;
    set restoreFocus(value: boolean);
    select(date: D): void;
    _selectMonth(normalizedMonth: D): void;
    _selectYear(normalizedYear: D): void;
    get startAt(): D | null;
    set startAt(value: D | null);
    startView: 'month' | 'year' | 'multi-year';
    readonly stateChanges: Subject<void>;
    get touchUi(): boolean;
    set touchUi(value: boolean);
    readonly viewChanged: EventEmitter<MatCalendarView>;
    _viewChanged(view: MatCalendarView): void;
    xPosition: DatepickerDropdownPositionX;
    readonly yearSelected: EventEmitter<D>;
    yPosition: DatepickerDropdownPositionY;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<MatDatepickerBase<any, any, any>, never, never, { "calendarHeaderComponent": "calendarHeaderComponent"; "startAt": "startAt"; "startView": "startView"; "color": "color"; "touchUi": "touchUi"; "disabled": "disabled"; "xPosition": "xPosition"; "yPosition": "yPosition"; "restoreFocus": "restoreFocus"; "dateClass": "dateClass"; "panelClass": "panelClass"; "opened": "opened"; }, { "yearSelected": "yearSelected"; "monthSelected": "monthSelected"; "viewChanged": "viewChanged"; "openedStream": "opened"; "closedStream": "closed"; }, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatDatepickerBase<any, any, any>, [null, null, null, null, { optional: true; }, { optional: true; }, null]>;
}

// @public
export class MatDatepickerCancel {
    constructor(_datepicker: MatDatepickerBase<MatDatepickerControl<unknown>, unknown>);
    // (undocumented)
    _datepicker: MatDatepickerBase<MatDatepickerControl<unknown>, unknown>;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<MatDatepickerCancel, "[matDatepickerCancel], [matDateRangePickerCancel]", never, {}, {}, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatDatepickerCancel, never>;
}

// @public
export class MatDatepickerContent<S, D = ExtractDateTypeFromSelection<S>> extends _MatDatepickerContentBase implements OnInit, AfterViewInit, OnDestroy, CanColor {
    constructor(elementRef: ElementRef, _changeDetectorRef: ChangeDetectorRef, _globalModel: MatDateSelectionModel<S, D>, _dateAdapter: DateAdapter<D>, _rangeSelectionStrategy: MatDateRangeSelectionStrategy<D>, intl: MatDatepickerIntl);
    _actionsPortal: TemplatePortal | null;
    readonly _animationDone: Subject<void>;
    _animationState: 'enter-dropdown' | 'enter-dialog' | 'void';
    _applyPendingSelection(): void;
    _calendar: MatCalendar<D>;
    _closeButtonFocused: boolean;
    _closeButtonText: string;
    comparisonEnd: D | null;
    comparisonStart: D | null;
    datepicker: MatDatepickerBase<any, S, D>;
    // (undocumented)
    _getSelected(): D | DateRange<D> | null;
    // (undocumented)
    _handleUserSelection(event: MatCalendarUserEvent<D | null>): void;
    _isAbove: boolean;
    // (undocumented)
    ngAfterViewInit(): void;
    // (undocumented)
    ngOnDestroy(): void;
    // (undocumented)
    ngOnInit(): void;
    // (undocumented)
    _startExitAnimation(): void;
    // (undocumented)
    static ɵcmp: i0.ɵɵComponentDeclaration<MatDatepickerContent<any, any>, "mat-datepicker-content", ["matDatepickerContent"], { "color": "color"; }, {}, never, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatDatepickerContent<any, any>, [null, null, null, null, { optional: true; }, null]>;
}

// @public
interface MatDatepickerControl<D> {
    // (undocumented)
    dateFilter: DateFilterFn<D>;
    // (undocumented)
    disabled: boolean;
    // (undocumented)
    getConnectedOverlayOrigin(): ElementRef;
    // (undocumented)
    getOverlayLabelId(): string | null;
    // (undocumented)
    getStartValue(): D | null;
    // (undocumented)
    getThemePalette(): ThemePalette;
    // (undocumented)
    max: D | null;
    // (undocumented)
    min: D | null;
    // (undocumented)
    stateChanges: Observable<void>;
}

// @public
export class MatDatepickerInput<D> extends MatDatepickerInputBase<D | null, D> implements MatDatepickerControl<D | null>, OnDestroy {
    constructor(elementRef: ElementRef<HTMLInputElement>, dateAdapter: DateAdapter<D>, dateFormats: MatDateFormats, _formField?: MatFormField | undefined);
    // (undocumented)
    protected _assignValueToModel(value: D | null): void;
    get dateFilter(): DateFilterFn<D | null>;
    set dateFilter(value: DateFilterFn<D | null>);
    // (undocumented)
    _datepicker: MatDatepickerPanel<MatDatepickerControl<D>, D | null, D>;
    getConnectedOverlayOrigin(): ElementRef;
    protected _getDateFilter(): DateFilterFn<D | null>;
    _getMaxDate(): D | null;
    _getMinDate(): D | null;
    getOverlayLabelId(): string | null;
    getStartValue(): D | null;
    getThemePalette(): ThemePalette;
    // (undocumented)
    protected _getValueFromModel(modelValue: D | null): D | null;
    set matDatepicker(datepicker: MatDatepickerPanel<MatDatepickerControl<D>, D | null, D>);
    get max(): D | null;
    set max(value: D | null);
    get min(): D | null;
    set min(value: D | null);
    // (undocumented)
    ngOnDestroy(): void;
    protected _openPopup(): void;
    // (undocumented)
    protected _shouldHandleChangeEvent(event: DateSelectionModelChange<D>): boolean;
    protected _validator: ValidatorFn | null;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<MatDatepickerInput<any>, "input[matDatepicker]", ["matDatepickerInput"], { "matDatepicker": "matDatepicker"; "min": "min"; "max": "max"; "dateFilter": "matDatepickerFilter"; }, {}, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatDatepickerInput<any>, [null, { optional: true; }, { optional: true; }, { optional: true; }]>;
}

// @public
export class MatDatepickerInputEvent<D, S = unknown> {
    constructor(
    target: MatDatepickerInputBase<S, D>,
    targetElement: HTMLElement);
    target: MatDatepickerInputBase<S, D>;
    targetElement: HTMLElement;
    value: D | null;
}

// @public
export class MatDatepickerIntl {
    calendarLabel: string;
    readonly changes: Subject<void>;
    closeCalendarLabel: string;
    formatYearRange(start: string, end: string): string;
    nextMonthLabel: string;
    nextMultiYearLabel: string;
    nextYearLabel: string;
    openCalendarLabel: string;
    prevMonthLabel: string;
    prevMultiYearLabel: string;
    prevYearLabel: string;
    switchToMonthViewLabel: string;
    switchToMultiYearViewLabel: string;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatDatepickerIntl, never>;
    // (undocumented)
    static ɵprov: i0.ɵɵInjectableDeclaration<MatDatepickerIntl>;
}

// @public (undocumented)
export class MatDatepickerModule {
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatDatepickerModule, never>;
    // (undocumented)
    static ɵinj: i0.ɵɵInjectorDeclaration<MatDatepickerModule>;
    // (undocumented)
    static ɵmod: i0.ɵɵNgModuleDeclaration<MatDatepickerModule, [typeof i1.MatCalendar, typeof i2.MatCalendarBody, typeof i3.MatDatepicker, typeof i4.MatDatepickerContent, typeof i5.MatDatepickerInput, typeof i6.MatDatepickerToggle, typeof i6.MatDatepickerToggleIcon, typeof i7.MatMonthView, typeof i8.MatYearView, typeof i9.MatMultiYearView, typeof i1.MatCalendarHeader, typeof i10.MatDateRangeInput, typeof i11.MatStartDate, typeof i11.MatEndDate, typeof i12.MatDateRangePicker, typeof i13.MatDatepickerActions, typeof i13.MatDatepickerCancel, typeof i13.MatDatepickerApply], [typeof i14.CommonModule, typeof i15.MatButtonModule, typeof i16.OverlayModule, typeof i17.A11yModule, typeof i18.PortalModule, typeof i19.MatCommonModule], [typeof i20.CdkScrollableModule, typeof i1.MatCalendar, typeof i2.MatCalendarBody, typeof i3.MatDatepicker, typeof i4.MatDatepickerContent, typeof i5.MatDatepickerInput, typeof i6.MatDatepickerToggle, typeof i6.MatDatepickerToggleIcon, typeof i7.MatMonthView, typeof i8.MatYearView, typeof i9.MatMultiYearView, typeof i1.MatCalendarHeader, typeof i10.MatDateRangeInput, typeof i11.MatStartDate, typeof i11.MatEndDate, typeof i12.MatDateRangePicker, typeof i13.MatDatepickerActions, typeof i13.MatDatepickerCancel, typeof i13.MatDatepickerApply]>;
}

// @public
interface MatDatepickerPanel<C extends MatDatepickerControl<D>, S, D = ExtractDateTypeFromSelection<S>> {
    closedStream: EventEmitter<void>;
    color: ThemePalette;
    datepickerInput: C;
    disabled: boolean;
    id: string;
    open(): void;
    opened: boolean;
    openedStream: EventEmitter<void>;
    registerInput(input: C): MatDateSelectionModel<S, D>;
    stateChanges: Subject<void>;
}

// @public (undocumented)
export class MatDatepickerToggle<D> implements AfterContentInit, OnChanges, OnDestroy {
    constructor(_intl: MatDatepickerIntl, _changeDetectorRef: ChangeDetectorRef, defaultTabIndex: string);
    ariaLabel: string;
    _button: MatButton;
    _customIcon: MatDatepickerToggleIcon;
    datepicker: MatDatepickerPanel<MatDatepickerControl<any>, D>;
    get disabled(): boolean;
    set disabled(value: boolean);
    disableRipple: boolean;
    // (undocumented)
    _intl: MatDatepickerIntl;
    // (undocumented)
    static ngAcceptInputType_disabled: BooleanInput;
    // (undocumented)
    ngAfterContentInit(): void;
    // (undocumented)
    ngOnChanges(changes: SimpleChanges): void;
    // (undocumented)
    ngOnDestroy(): void;
    // (undocumented)
    _open(event: Event): void;
    tabIndex: number | null;
    // (undocumented)
    static ɵcmp: i0.ɵɵComponentDeclaration<MatDatepickerToggle<any>, "mat-datepicker-toggle", ["matDatepickerToggle"], { "datepicker": "for"; "tabIndex": "tabIndex"; "ariaLabel": "aria-label"; "disabled": "disabled"; "disableRipple": "disableRipple"; }, {}, ["_customIcon"], ["[matDatepickerToggleIcon]"]>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatDatepickerToggle<any>, [null, null, { attribute: "tabindex"; }]>;
}

// @public
export class MatDatepickerToggleIcon {
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<MatDatepickerToggleIcon, "[matDatepickerToggleIcon]", never, {}, {}, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatDatepickerToggleIcon, never>;
}

// @public (undocumented)
export class MatDateRangeInput<D> implements MatFormFieldControl<DateRange<D>>, MatDatepickerControl<D>, MatDateRangeInputParent<D>, MatDateRangePickerInput<D>, AfterContentInit, OnChanges, OnDestroy {
    constructor(_changeDetectorRef: ChangeDetectorRef, _elementRef: ElementRef<HTMLElement>, control: ControlContainer, _dateAdapter: DateAdapter<D>, _formField?: MatFormField | undefined);
    _ariaDescribedBy: string | null;
    comparisonEnd: D | null;
    comparisonStart: D | null;
    controlType: string;
    get dateFilter(): DateFilterFn<D>;
    set dateFilter(value: DateFilterFn<D>);
    get disabled(): boolean;
    set disabled(value: boolean);
    get empty(): boolean;
    // (undocumented)
    _endInput: MatEndDate<D>;
    get errorState(): boolean;
    focused: boolean;
    _getAriaLabelledby(): string | null;
    getConnectedOverlayOrigin(): ElementRef;
    _getInputMirrorValue(): string;
    getOverlayLabelId(): string | null;
    getStartValue(): D | null;
    getThemePalette(): ThemePalette;
    // (undocumented)
    _groupDisabled: boolean;
    _handleChildValueChange(): void;
    id: string;
    get max(): D | null;
    set max(value: D | null);
    get min(): D | null;
    set min(value: D | null);
    // (undocumented)
    static ngAcceptInputType_disabled: BooleanInput;
    // (undocumented)
    static ngAcceptInputType_required: BooleanInput;
    // (undocumented)
    ngAfterContentInit(): void;
    ngControl: NgControl | null;
    // (undocumented)
    ngOnChanges(changes: SimpleChanges): void;
    // (undocumented)
    ngOnDestroy(): void;
    onContainerClick(): void;
    _openDatepicker(): void;
    get placeholder(): string;
    get rangePicker(): MatDatepickerPanel<MatDatepickerControl<D>, DateRange<D>, D>;
    set rangePicker(rangePicker: MatDatepickerPanel<MatDatepickerControl<D>, DateRange<D>, D>);
    get required(): boolean;
    set required(value: boolean);
    separator: string;
    setDescribedByIds(ids: string[]): void;
    _shouldHidePlaceholders(): boolean;
    _shouldHideSeparator(): boolean | "" | null;
    get shouldLabelFloat(): boolean;
    // (undocumented)
    _startInput: MatStartDate<D>;
    readonly stateChanges: Subject<void>;
    _updateFocus(origin: FocusOrigin): void;
    get value(): DateRange<D> | null;
    // (undocumented)
    static ɵcmp: i0.ɵɵComponentDeclaration<MatDateRangeInput<any>, "mat-date-range-input", ["matDateRangeInput"], { "rangePicker": "rangePicker"; "required": "required"; "dateFilter": "dateFilter"; "min": "min"; "max": "max"; "disabled": "disabled"; "separator": "separator"; "comparisonStart": "comparisonStart"; "comparisonEnd": "comparisonEnd"; }, {}, ["_startInput", "_endInput"], ["input[matStartDate]", "input[matEndDate]"]>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatDateRangeInput<any>, [null, null, { optional: true; self: true; }, { optional: true; }, { optional: true; }]>;
}

// @public
interface MatDateRangeInputParent<D> {
    // (undocumented)
    dateFilter: DateFilterFn<D>;
    // (undocumented)
    _endInput: MatDateRangeInputPartBase<D>;
    // (undocumented)
    _groupDisabled: boolean;
    // (undocumented)
    _handleChildValueChange(): void;
    // (undocumented)
    id: string;
    // (undocumented)
    max: D | null;
    // (undocumented)
    min: D | null;
    // (undocumented)
    _openDatepicker(): void;
    // (undocumented)
    rangePicker: {
        opened: boolean;
        id: string;
    };
    // (undocumented)
    _startInput: MatDateRangeInputPartBase<D>;
}

// @public
export class MatDateRangePicker<D> extends MatDatepickerBase<MatDateRangePickerInput<D>, DateRange<D>, D> {
    // (undocumented)
    protected _forwardContentValues(instance: MatDatepickerContent<DateRange<D>, D>): void;
    // (undocumented)
    static ɵcmp: i0.ɵɵComponentDeclaration<MatDateRangePicker<any>, "mat-date-range-picker", ["matDateRangePicker"], {}, {}, never, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatDateRangePicker<any>, never>;
}

// @public
interface MatDateRangePickerInput<D> extends MatDatepickerControl<D> {
    // (undocumented)
    comparisonEnd: D | null;
    // (undocumented)
    comparisonStart: D | null;
}

// @public
export interface MatDateRangeSelectionStrategy<D> {
    createPreview(activeDate: D | null, currentRange: DateRange<D>, event: Event): DateRange<D>;
    selectionFinished(date: D | null, currentRange: DateRange<D>, event: Event): DateRange<D>;
}

// @public
export abstract class MatDateSelectionModel<S, D = ExtractDateTypeFromSelection<S>> implements OnDestroy {
    protected constructor(
    selection: S, _adapter: DateAdapter<D>);
    // (undocumented)
    protected _adapter: DateAdapter<D>;
    abstract add(date: D | null): void;
    abstract clone(): MatDateSelectionModel<S, D>;
    abstract isComplete(): boolean;
    abstract isValid(): boolean;
    // (undocumented)
    protected _isValidDateInstance(date: D): boolean;
    // (undocumented)
    ngOnDestroy(): void;
    readonly selection: S;
    selectionChanged: Observable<DateSelectionModelChange<S>>;
    updateSelection(value: S, source: unknown): void;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatDateSelectionModel<any, any>, never>;
    // (undocumented)
    static ɵprov: i0.ɵɵInjectableDeclaration<MatDateSelectionModel<any, any>>;
}

// @public
export class MatEndDate<D> extends _MatDateRangeInputBase<D> implements CanUpdateErrorState {
    constructor(rangeInput: MatDateRangeInputParent<D>, elementRef: ElementRef<HTMLInputElement>, defaultErrorStateMatcher: ErrorStateMatcher, injector: Injector, parentForm: NgForm, parentFormGroup: FormGroupDirective, dateAdapter: DateAdapter<D>, dateFormats: MatDateFormats);
    // (undocumented)
    protected _assignValueToModel(value: D | null): void;
    // (undocumented)
    protected _getValueFromModel(modelValue: DateRange<D>): D | null;
    // (undocumented)
    _onKeydown(event: KeyboardEvent): void;
    // (undocumented)
    protected _shouldHandleChangeEvent(change: DateSelectionModelChange<DateRange<D>>): boolean;
    // (undocumented)
    protected _validator: ValidatorFn | null;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<MatEndDate<any>, "input[matEndDate]", never, { "errorStateMatcher": "errorStateMatcher"; }, { "dateChange": "dateChange"; "dateInput": "dateInput"; }, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatEndDate<any>, [null, null, null, null, { optional: true; }, { optional: true; }, { optional: true; }, { optional: true; }]>;
}

// @public
export class MatMonthView<D> implements AfterContentInit, OnChanges, OnDestroy {
    constructor(_changeDetectorRef: ChangeDetectorRef, _dateFormats: MatDateFormats, _dateAdapter: DateAdapter<D>, _dir?: Directionality | undefined, _rangeStrategy?: MatDateRangeSelectionStrategy<D> | undefined);
    get activeDate(): D;
    set activeDate(value: D);
    readonly activeDateChange: EventEmitter<D>;
    // (undocumented)
    readonly _changeDetectorRef: ChangeDetectorRef;
    comparisonEnd: D | null;
    _comparisonRangeEnd: number | null;
    _comparisonRangeStart: number | null;
    comparisonStart: D | null;
    // (undocumented)
    _dateAdapter: DateAdapter<D>;
    dateClass: MatCalendarCellClassFunction<D>;
    dateFilter: (date: D) => boolean;
    _dateSelected(event: MatCalendarUserEvent<number>): void;
    _firstWeekOffset: number;
    _focusActiveCell(movePreview?: boolean): void;
    _handleCalendarBodyKeydown(event: KeyboardEvent): void;
    _handleCalendarBodyKeyup(event: KeyboardEvent): void;
    _init(): void;
    _isRange: boolean;
    _matCalendarBody: MatCalendarBody;
    get maxDate(): D | null;
    set maxDate(value: D | null);
    get minDate(): D | null;
    set minDate(value: D | null);
    _monthLabel: string;
    // (undocumented)
    ngAfterContentInit(): void;
    // (undocumented)
    ngOnChanges(changes: SimpleChanges): void;
    // (undocumented)
    ngOnDestroy(): void;
    _previewChanged({ event, value: cell }: MatCalendarUserEvent<MatCalendarCell<D> | null>): void;
    _previewEnd: number | null;
    _previewStart: number | null;
    _rangeEnd: number | null;
    _rangeStart: number | null;
    get selected(): DateRange<D> | D | null;
    set selected(value: DateRange<D> | D | null);
    readonly selectedChange: EventEmitter<D | null>;
    _todayDate: number | null;
    readonly _userSelection: EventEmitter<MatCalendarUserEvent<D | null>>;
    _weekdays: {
        long: string;
        narrow: string;
    }[];
    _weeks: MatCalendarCell[][];
    // (undocumented)
    static ɵcmp: i0.ɵɵComponentDeclaration<MatMonthView<any>, "mat-month-view", ["matMonthView"], { "activeDate": "activeDate"; "selected": "selected"; "minDate": "minDate"; "maxDate": "maxDate"; "dateFilter": "dateFilter"; "dateClass": "dateClass"; "comparisonStart": "comparisonStart"; "comparisonEnd": "comparisonEnd"; }, { "selectedChange": "selectedChange"; "_userSelection": "_userSelection"; "activeDateChange": "activeDateChange"; }, never, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatMonthView<any>, [null, { optional: true; }, { optional: true; }, { optional: true; }, { optional: true; }]>;
}

// @public
export class MatMultiYearView<D> implements AfterContentInit, OnDestroy {
    constructor(_changeDetectorRef: ChangeDetectorRef, _dateAdapter: DateAdapter<D>, _dir?: Directionality | undefined);
    get activeDate(): D;
    set activeDate(value: D);
    readonly activeDateChange: EventEmitter<D>;
    // (undocumented)
    _dateAdapter: DateAdapter<D>;
    dateClass: MatCalendarCellClassFunction<D>;
    dateFilter: (date: D) => boolean;
    _focusActiveCell(): void;
    // (undocumented)
    _getActiveCell(): number;
    _handleCalendarBodyKeydown(event: KeyboardEvent): void;
    _handleCalendarBodyKeyup(event: KeyboardEvent): void;
    _init(): void;
    _matCalendarBody: MatCalendarBody;
    get maxDate(): D | null;
    set maxDate(value: D | null);
    get minDate(): D | null;
    set minDate(value: D | null);
    // (undocumented)
    ngAfterContentInit(): void;
    // (undocumented)
    ngOnDestroy(): void;
    get selected(): DateRange<D> | D | null;
    set selected(value: DateRange<D> | D | null);
    readonly selectedChange: EventEmitter<D>;
    _selectedYear: number | null;
    _todayYear: number;
    _years: MatCalendarCell[][];
    readonly yearSelected: EventEmitter<D>;
    _yearSelected(event: MatCalendarUserEvent<number>): void;
    // (undocumented)
    static ɵcmp: i0.ɵɵComponentDeclaration<MatMultiYearView<any>, "mat-multi-year-view", ["matMultiYearView"], { "activeDate": "activeDate"; "selected": "selected"; "minDate": "minDate"; "maxDate": "maxDate"; "dateFilter": "dateFilter"; "dateClass": "dateClass"; }, { "selectedChange": "selectedChange"; "yearSelected": "yearSelected"; "activeDateChange": "activeDateChange"; }, never, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatMultiYearView<any>, [null, { optional: true; }, { optional: true; }]>;
}

// @public
export class MatRangeDateSelectionModel<D> extends MatDateSelectionModel<DateRange<D>, D> {
    constructor(adapter: DateAdapter<D>);
    add(date: D | null): void;
    clone(): MatRangeDateSelectionModel<D>;
    isComplete(): boolean;
    isValid(): boolean;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatRangeDateSelectionModel<any>, never>;
    // (undocumented)
    static ɵprov: i0.ɵɵInjectableDeclaration<MatRangeDateSelectionModel<any>>;
}

// @public
export class MatSingleDateSelectionModel<D> extends MatDateSelectionModel<D | null, D> {
    constructor(adapter: DateAdapter<D>);
    add(date: D | null): void;
    clone(): MatSingleDateSelectionModel<D>;
    isComplete(): boolean;
    isValid(): boolean;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatSingleDateSelectionModel<any>, never>;
    // (undocumented)
    static ɵprov: i0.ɵɵInjectableDeclaration<MatSingleDateSelectionModel<any>>;
}

// @public
export class MatStartDate<D> extends _MatDateRangeInputBase<D> implements CanUpdateErrorState {
    constructor(rangeInput: MatDateRangeInputParent<D>, elementRef: ElementRef<HTMLInputElement>, defaultErrorStateMatcher: ErrorStateMatcher, injector: Injector, parentForm: NgForm, parentFormGroup: FormGroupDirective, dateAdapter: DateAdapter<D>, dateFormats: MatDateFormats);
    // (undocumented)
    protected _assignValueToModel(value: D | null): void;
    // (undocumented)
    protected _formatValue(value: D | null): void;
    getMirrorValue(): string;
    // (undocumented)
    protected _getValueFromModel(modelValue: DateRange<D>): D | null;
    // (undocumented)
    protected _shouldHandleChangeEvent(change: DateSelectionModelChange<DateRange<D>>): boolean;
    // (undocumented)
    protected _validator: ValidatorFn | null;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<MatStartDate<any>, "input[matStartDate]", never, { "errorStateMatcher": "errorStateMatcher"; }, { "dateChange": "dateChange"; "dateInput": "dateInput"; }, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatStartDate<any>, [null, null, null, null, { optional: true; }, { optional: true; }, { optional: true; }, { optional: true; }]>;
}

// @public
export class MatYearView<D> implements AfterContentInit, OnDestroy {
    constructor(_changeDetectorRef: ChangeDetectorRef, _dateFormats: MatDateFormats, _dateAdapter: DateAdapter<D>, _dir?: Directionality | undefined);
    get activeDate(): D;
    set activeDate(value: D);
    readonly activeDateChange: EventEmitter<D>;
    // (undocumented)
    readonly _changeDetectorRef: ChangeDetectorRef;
    // (undocumented)
    _dateAdapter: DateAdapter<D>;
    dateClass: MatCalendarCellClassFunction<D>;
    dateFilter: (date: D) => boolean;
    _focusActiveCell(): void;
    _handleCalendarBodyKeydown(event: KeyboardEvent): void;
    _handleCalendarBodyKeyup(event: KeyboardEvent): void;
    _init(): void;
    _matCalendarBody: MatCalendarBody;
    get maxDate(): D | null;
    set maxDate(value: D | null);
    get minDate(): D | null;
    set minDate(value: D | null);
    _months: MatCalendarCell[][];
    readonly monthSelected: EventEmitter<D>;
    _monthSelected(event: MatCalendarUserEvent<number>): void;
    // (undocumented)
    ngAfterContentInit(): void;
    // (undocumented)
    ngOnDestroy(): void;
    get selected(): DateRange<D> | D | null;
    set selected(value: DateRange<D> | D | null);
    readonly selectedChange: EventEmitter<D>;
    _selectedMonth: number | null;
    _todayMonth: number | null;
    _yearLabel: string;
    // (undocumented)
    static ɵcmp: i0.ɵɵComponentDeclaration<MatYearView<any>, "mat-year-view", ["matYearView"], { "activeDate": "activeDate"; "selected": "selected"; "minDate": "minDate"; "maxDate": "maxDate"; "dateFilter": "dateFilter"; "dateClass": "dateClass"; }, { "selectedChange": "selectedChange"; "monthSelected": "monthSelected"; "activeDateChange": "activeDateChange"; }, never, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatYearView<any>, [null, { optional: true; }, { optional: true; }, { optional: true; }]>;
}

// @public (undocumented)
export const yearsPerPage = 24;

// @public (undocumented)
export const yearsPerRow = 4;

// (No @packageDocumentation comment for this package)

```
