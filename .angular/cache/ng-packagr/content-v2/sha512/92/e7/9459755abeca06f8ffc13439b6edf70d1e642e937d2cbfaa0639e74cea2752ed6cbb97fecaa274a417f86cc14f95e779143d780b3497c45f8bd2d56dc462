{"hash":"51911fef764a88ef6b2a19354ce71c3bfbf79034","fesm2020":{"code":"import { InjectionToken, inject, LOCALE_ID } from '@angular/core';\nimport { Subject } from 'rxjs';\n\nconst MC_DATE_FORMATS = new InjectionToken('mc-date-formats');\n\n/** InjectionToken for datepicker that can be used to override default locale code. */\nconst MC_DATE_LOCALE = new InjectionToken('MC_DATE_LOCALE', {\n    providedIn: 'root',\n    factory: MC_DATE_LOCALE_FACTORY\n});\n/** @docs-private */\n// tslint:disable-next-line:naming-convention\nfunction MC_DATE_LOCALE_FACTORY() {\n    return inject(LOCALE_ID);\n}\n/** Adapts type `D` to be usable as a date by cdk-based components that work with dates. */\n// tslint:disable-next-line:naming-convention\nclass DateAdapter {\n    constructor() {\n        this._localeChanges = new Subject();\n    }\n    /** A stream that emits when the locale changes. */\n    get localeChanges() {\n        return this._localeChanges;\n    }\n    /**\n     * Attempts to deserialize a value to a valid date object. This is different from parsing in that\n     * deserialize should only accept non-ambiguous, locale-independent formats (e.g. a ISO 8601\n     * string). The default implementation does not allow any deserialization, it simply checks that\n     * the given value is already a valid date object or null. The `<mat-datepicker>` will call this\n     * method on all of it's `@Input()` properties that accept dates. It is therefore possible to\n     * support passing values from your backend directly to these properties by overriding this method\n     * to also deserialize the format used by your backend.\n     * @param value The value to be deserialized into a date object.\n     * @returns The deserialized date object, either a valid date, null if the value can be\n     *     deserialized into a null date (e.g. the empty string), or an invalid date.\n     */\n    deserialize(value) {\n        if (value == null || this.isDateInstance(value) && this.isValid(value)) {\n            return value;\n        }\n        return this.invalid();\n    }\n    /**\n     * Sets the locale used for all dates.\n     * @param locale The new locale.\n     */\n    setLocale(locale) {\n        this.locale = locale;\n        this._localeChanges.next();\n    }\n    /**\n     * Compares two dates.\n     * @param first The first date to compare.\n     * @param second The second date to compare.\n     * @returns 0 if the dates are equal, a number less than 0 if the first date is earlier,\n     *     a number greater than 0 if the first date is later.\n     */\n    compareDate(first, second) {\n        return this.getYear(first) - this.getYear(second) ||\n            this.getMonth(first) - this.getMonth(second) ||\n            this.getDate(first) - this.getDate(second);\n    }\n    /**\n     * Compares two dates.\n     * @param first The first date to compare.\n     * @param second The second date to compare.\n     * @returns 0 if the dates are equal, a number less than 0 if the first date is earlier,\n     *     a number greater than 0 if the first date is later.\n     */\n    compareDateTime(first, second) {\n        return this.getYear(first) - this.getYear(second) ||\n            this.getMonth(first) - this.getMonth(second) ||\n            this.getDate(first) - this.getDate(second) ||\n            this.getHours(first) - this.getHours(second) ||\n            this.getMinutes(first) - this.getMinutes(second) ||\n            this.getSeconds(first) - this.getSeconds(second) ||\n            this.getMilliseconds(first) - this.getMilliseconds(second);\n    }\n    /**\n     * Checks if two dates are equal.\n     * @param first The first date to check.\n     * @param second The second date to check.\n     * @returns Whether the two dates are equal.\n     *     Null dates are considered equal to other null dates.\n     */\n    sameDate(first, second) {\n        if (first && second) {\n            const firstValid = this.isValid(first);\n            const secondValid = this.isValid(second);\n            if (firstValid && secondValid) {\n                return !this.compareDate(first, second);\n            }\n            return firstValid === secondValid;\n        }\n        return first === second;\n    }\n    /**\n     * Clamp the given date between min and max dates.\n     * @param date The date to clamp.\n     * @param min The minimum value to allow. If null or omitted no min is enforced.\n     * @param max The maximum value to allow. If null or omitted no max is enforced.\n     * @returns `min` if `date` is less than `min`, `max` if date is greater than `max`,\n     *     otherwise `date`.\n     */\n    clampDate(date, min, max) {\n        if (min && this.compareDate(date, min) < 0) {\n            return min;\n        }\n        if (max && this.compareDate(date, max) > 0) {\n            return max;\n        }\n        return date;\n    }\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { DateAdapter, MC_DATE_FORMATS, MC_DATE_LOCALE, MC_DATE_LOCALE_FACTORY };\n//# sourceMappingURL=ptsecurity-cdk-datetime.mjs.map\n","map":{"version":3,"file":"ptsecurity-cdk-datetime.mjs","sources":["../../../packages/cdk/datetime/date-formats.ts","../../../packages/cdk/datetime/date-adapter.ts","../../../packages/cdk/datetime/ptsecurity-cdk-datetime.ts"],"sourcesContent":["import { InjectionToken } from '@angular/core';\n\n\n// tslint:disable-next-line:naming-convention\nexport interface McDateFormats {\n    dateInput: any;\n    monthYearLabel: any;\n    dateA11yLabel: any;\n    monthYearA11yLabel: any;\n}\n\nexport const MC_DATE_FORMATS = new InjectionToken<McDateFormats>('mc-date-formats');\n","import { inject, InjectionToken, LOCALE_ID } from '@angular/core';\nimport { Observable, Subject } from 'rxjs';\n\n\n/** InjectionToken for datepicker that can be used to override default locale code. */\nexport const MC_DATE_LOCALE = new InjectionToken<string>('MC_DATE_LOCALE', {\n    providedIn: 'root',\n    factory: MC_DATE_LOCALE_FACTORY\n});\n\n/** @docs-private */\n// tslint:disable-next-line:naming-convention\nexport function MC_DATE_LOCALE_FACTORY(): string {\n    return inject(LOCALE_ID);\n}\n\n// tslint:disable-next-line:naming-convention\nexport interface DateAdapterConfig {\n    variables: { [name: string]: string };\n\n    monthNames: {\n        long: string[];\n        short: {\n            standalone: string[];\n            formatted: string[];\n        };\n        narrow: string[];\n    };\n\n    dayOfWeekNames: {\n        long: string[];\n        short: string[];\n        narrow: string[];\n    };\n\n    firstDayOfWeek: number;\n}\n\n\n/** Adapts type `D` to be usable as a date by cdk-based components that work with dates. */\n// tslint:disable-next-line:naming-convention\nexport abstract class DateAdapter<D> {\n    config: DateAdapterConfig;\n\n    /** The locale to use for all dates. */\n    protected locale: any;\n\n    /** A stream that emits when the locale changes. */\n    get localeChanges(): Observable<any> {\n        return this._localeChanges;\n    }\n\n    private _localeChanges = new Subject<void>();\n\n    /**\n     * Gets the year component of the given date.\n     * @param date The date to extract the year from.\n     * @returns The year component.\n     */\n    abstract getYear(date: D): number;\n\n    /**\n     * Gets the month component of the given date.\n     * @param date The date to extract the month from.\n     * @returns The month component (0-indexed, 0 = January).\n     */\n    abstract getMonth(date: D): number;\n\n    /**\n     * Gets the date of the month component of the given date.\n     * @param date The date to extract the date of the month from.\n     * @returns The month component (1-indexed, 1 = first of month).\n     */\n    abstract getDate(date: D): number;\n\n    /**\n     * Gets the day of the week component of the given date.\n     * @param date The date to extract the day of the week from.\n     * @returns The month component (0-indexed, 0 = Sunday).\n     */\n    abstract getDayOfWeek(date: D): number;\n\n    /**\n     * Gets the hours component of the given date.\n     * @param date The date to extract from.\n     * @returns The hours component in 24h format.\n     */\n    abstract getHours(date: D): number;\n\n    /**\n     * Gets the minutes component of the given date.\n     * @param date The date to extract from.\n     * @returns The minutes component\n     */\n    abstract getMinutes(date: D): number;\n\n    /**\n     * Gets the seconds component of the given date.\n     * @param date The date to extract from.\n     * @returns The seconds component\n     */\n    abstract getSeconds(date: D): number;\n\n    /**\n     * Gets the milliseconds component of the given date.\n     * @param date The date to extract from.\n     * @returns The milliseconds component\n     */\n    abstract getMilliseconds(date: D): number;\n\n    /**\n     * Gets returns the number of milliseconds since the Unix Epoch of the given date.\n     * @param date The date to extract from.\n     * @returns The milliseconds\n     */\n    abstract getTime(date: D): number;\n\n    /**\n     * Gets a list of names for the months.\n     * @param style The naming style (e.g. long = 'January', short = 'Jan', narrow = 'J').\n     * @returns An ordered list of all month names, starting with January.\n     */\n    abstract getMonthNames(style: 'long' | 'short' | 'narrow'): string[];\n\n    /**\n     * Gets a list of names for the dates of the month.\n     * @returns An ordered list of all date of the month names, starting with '1'.\n     */\n    abstract getDateNames(): string[];\n\n    /**\n     * Gets a list of names for the days of the week.\n     * @param style The naming style (e.g. long = 'Sunday', short = 'Sun', narrow = 'S').\n     * @returns An ordered list of all weekday names, starting with Sunday.\n     */\n    abstract getDayOfWeekNames(style: 'long' | 'short' | 'narrow'): string[];\n\n    /**\n     * Gets the name for the year of the given date.\n     * @param date The date to get the year name for.\n     * @returns The name of the given year (e.g. '2017').\n     */\n    abstract getYearName(date: D): string;\n\n    /**\n     * Gets the first day of the week.\n     * @returns The first day of the week (0-indexed, 0 = Sunday).\n     */\n    abstract getFirstDayOfWeek(): number;\n\n    /**\n     * Gets the number of days in the month of the given date.\n     * @param date The date whose month should be checked.\n     * @returns The number of days in the month of the given date.\n     */\n    abstract getNumDaysInMonth(date: D): number;\n\n    /**\n     * Clones the given date.\n     * @param date The date to clone\n     * @returns A new date equal to the given date.\n     */\n    abstract clone(date: D): D;\n\n    /**\n     * Creates a date with the given year, month, and date. Does not allow over/under-flow of the\n     * month and date.\n     * @param year The full year of the date. (e.g. 89 means the year 89, not the year 1989).\n     * @param month The month of the date (0-indexed, 0 = January). Must be an integer 0 - 11.\n     * @param date The date of month of the date. Must be an integer 1 - length of the given month.\n     * @returns The new date, or null if invalid.\n     */\n    abstract createDate(year: number, month?: number, date?: number): D;\n\n    /**\n     * Creates a date time with the given year, month, date, hours, minutes, seconds and milliseconds.\n     * Does not allow over/under-flow of the month and date.\n     * @param year The full year of the date. (e.g. 89 means the year 89, not the year 1989).\n     * @param month The month of the date (0-indexed, 0 = January). Must be an integer 0 - 11.\n     * @param date The date of month of the date. Must be an integer 1 - length of the given month.\n     * @param hours The date of month of the date. Must be an integer 1 - length of the given month.\n     * @param minutes The date of month of the date. Must be an integer 1 - length of the given month.\n     * @param seconds The date of month of the date. Must be an integer 1 - length of the given month.\n     * @param milliseconds The date of month of the date. Must be an integer 1 - length of the given month.\n     * @returns The new date, or null if invalid.\n     */\n    abstract createDateTime(\n        year: number, month: number, date: number,\n        hours: number, minutes: number, seconds: number, milliseconds: number\n    ): D;\n\n    /**\n     * Gets today's date.\n     * @returns Today's date.\n     */\n    abstract today(): D;\n\n    /**\n     * Parses a date from a user-provided value.\n     * @param value The value to parse.\n     * @param parseFormat The expected format of the value being parsed\n     *     (type is implementation-dependent).\n     * @returns The parsed date.\n     */\n    abstract parse(value: any, parseFormat: any): D | null;\n\n    /**\n     * Formats a date as a string according to the given format.\n     * @param date The value to format.\n     * @param displayFormat The format to use to display the date as a string.\n     * @returns The formatted date string.\n     */\n    abstract format(date: D, displayFormat: any): string;\n\n    /**\n     * Adds the given number of years to the date. Years are counted as if flipping 12 pages on the\n     * calendar for each year and then finding the closest date in the new month. For example when\n     * adding 1 year to Feb 29, 2016, the resulting date will be Feb 28, 2017.\n     * @param date The date to add years to.\n     * @param years The number of years to add (may be negative).\n     * @returns A new date equal to the given one with the specified number of years added.\n     */\n    abstract addCalendarYears(date: D, years: number): D;\n\n    /**\n     * Adds the given number of months to the date. Months are counted as if flipping a page on the\n     * calendar for each month and then finding the closest date in the new month. For example when\n     * adding 1 month to Jan 31, 2017, the resulting date will be Feb 28, 2017.\n     * @param date The date to add months to.\n     * @param months The number of months to add (may be negative).\n     * @returns A new date equal to the given one with the specified number of months added.\n     */\n    abstract addCalendarMonths(date: D, months: number): D;\n\n    /**\n     * Adds the given number of days to the date. Days are counted as if moving one cell on the\n     * calendar for each day.\n     * @param date The date to add days to.\n     * @param days The number of days to add (may be negative).\n     * @returns A new date equal to the given one with the specified number of days added.\n     */\n    abstract addCalendarDays(date: D, days: number): D;\n\n    /**\n     * Gets the RFC 3339 compatible string (https://tools.ietf.org/html/rfc3339) for the given date.\n     * This method is used to generate date strings that are compatible with native HTML attributes\n     * such as the `min` or `max` attribute of an `<input>`.\n     * @param date The date to get the ISO date string for.\n     * @returns The ISO date string date string.\n     */\n    abstract toIso8601(date: D): string;\n\n    /**\n     * Checks whether the given object is considered a date instance by this DateAdapter.\n     * @param obj The object to check\n     * @returns Whether the object is a date instance.\n     */\n    abstract isDateInstance(obj: any): boolean;\n\n    /**\n     * Checks whether the given date is valid.\n     * @param date The date to check.\n     * @returns Whether the date is valid.\n     */\n    abstract isValid(date: D): boolean;\n\n    /**\n     * Gets date instance that is not valid.\n     * @returns An invalid date.\n     */\n    abstract invalid(): D;\n\n    abstract hasSame(startDate: D, endDate: D, unit): boolean;\n\n    abstract diffNow(date: D, unit): number;\n\n    /**\n     * Attempts to deserialize a value to a valid date object. This is different from parsing in that\n     * deserialize should only accept non-ambiguous, locale-independent formats (e.g. a ISO 8601\n     * string). The default implementation does not allow any deserialization, it simply checks that\n     * the given value is already a valid date object or null. The `<mat-datepicker>` will call this\n     * method on all of it's `@Input()` properties that accept dates. It is therefore possible to\n     * support passing values from your backend directly to these properties by overriding this method\n     * to also deserialize the format used by your backend.\n     * @param value The value to be deserialized into a date object.\n     * @returns The deserialized date object, either a valid date, null if the value can be\n     *     deserialized into a null date (e.g. the empty string), or an invalid date.\n     */\n    deserialize(value: any): D | null {\n        if (value == null || this.isDateInstance(value) && this.isValid(value)) { return value; }\n\n        return this.invalid();\n    }\n\n    /**\n     * Sets the locale used for all dates.\n     * @param locale The new locale.\n     */\n    setLocale(locale: any) {\n        this.locale = locale;\n        this._localeChanges.next();\n    }\n\n    /**\n     * Compares two dates.\n     * @param first The first date to compare.\n     * @param second The second date to compare.\n     * @returns 0 if the dates are equal, a number less than 0 if the first date is earlier,\n     *     a number greater than 0 if the first date is later.\n     */\n    compareDate(first: D, second: D): number {\n        return this.getYear(first) - this.getYear(second) ||\n            this.getMonth(first) - this.getMonth(second) ||\n            this.getDate(first) - this.getDate(second);\n    }\n\n    /**\n     * Compares two dates.\n     * @param first The first date to compare.\n     * @param second The second date to compare.\n     * @returns 0 if the dates are equal, a number less than 0 if the first date is earlier,\n     *     a number greater than 0 if the first date is later.\n     */\n    compareDateTime(first: D, second: D): number {\n        return this.getYear(first) - this.getYear(second) ||\n            this.getMonth(first) - this.getMonth(second) ||\n            this.getDate(first) - this.getDate(second) ||\n            this.getHours(first) - this.getHours(second) ||\n            this.getMinutes(first) - this.getMinutes(second) ||\n            this.getSeconds(first) - this.getSeconds(second) ||\n            this.getMilliseconds(first) - this.getMilliseconds(second);\n    }\n\n    /**\n     * Checks if two dates are equal.\n     * @param first The first date to check.\n     * @param second The second date to check.\n     * @returns Whether the two dates are equal.\n     *     Null dates are considered equal to other null dates.\n     */\n    sameDate(first: D | null, second: D | null): boolean {\n        if (first && second) {\n            const firstValid = this.isValid(first);\n            const secondValid = this.isValid(second);\n\n            if (firstValid && secondValid) {\n                return !this.compareDate(first, second);\n            }\n\n            return firstValid === secondValid;\n        }\n\n        return first === second;\n    }\n\n    /**\n     * Clamp the given date between min and max dates.\n     * @param date The date to clamp.\n     * @param min The minimum value to allow. If null or omitted no min is enforced.\n     * @param max The maximum value to allow. If null or omitted no max is enforced.\n     * @returns `min` if `date` is less than `min`, `max` if date is greater than `max`,\n     *     otherwise `date`.\n     */\n    clampDate(date: D, min?: D | null, max?: D | null): D {\n        if (min && this.compareDate(date, min) < 0) { return min; }\n\n        if (max && this.compareDate(date, max) > 0) { return max; }\n\n        return date;\n    }\n}\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],"names":[],"mappings":"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"}},"fesm2015":{"code":"import { InjectionToken, inject, LOCALE_ID } from '@angular/core';\nimport { Subject } from 'rxjs';\n\nconst MC_DATE_FORMATS = new InjectionToken('mc-date-formats');\n\n/** InjectionToken for datepicker that can be used to override default locale code. */\nconst MC_DATE_LOCALE = new InjectionToken('MC_DATE_LOCALE', {\n    providedIn: 'root',\n    factory: MC_DATE_LOCALE_FACTORY\n});\n/** @docs-private */\n// tslint:disable-next-line:naming-convention\nfunction MC_DATE_LOCALE_FACTORY() {\n    return inject(LOCALE_ID);\n}\n/** Adapts type `D` to be usable as a date by cdk-based components that work with dates. */\n// tslint:disable-next-line:naming-convention\nclass DateAdapter {\n    constructor() {\n        this._localeChanges = new Subject();\n    }\n    /** A stream that emits when the locale changes. */\n    get localeChanges() {\n        return this._localeChanges;\n    }\n    /**\n     * Attempts to deserialize a value to a valid date object. This is different from parsing in that\n     * deserialize should only accept non-ambiguous, locale-independent formats (e.g. a ISO 8601\n     * string). The default implementation does not allow any deserialization, it simply checks that\n     * the given value is already a valid date object or null. The `<mat-datepicker>` will call this\n     * method on all of it's `@Input()` properties that accept dates. It is therefore possible to\n     * support passing values from your backend directly to these properties by overriding this method\n     * to also deserialize the format used by your backend.\n     * @param value The value to be deserialized into a date object.\n     * @returns The deserialized date object, either a valid date, null if the value can be\n     *     deserialized into a null date (e.g. the empty string), or an invalid date.\n     */\n    deserialize(value) {\n        if (value == null || this.isDateInstance(value) && this.isValid(value)) {\n            return value;\n        }\n        return this.invalid();\n    }\n    /**\n     * Sets the locale used for all dates.\n     * @param locale The new locale.\n     */\n    setLocale(locale) {\n        this.locale = locale;\n        this._localeChanges.next();\n    }\n    /**\n     * Compares two dates.\n     * @param first The first date to compare.\n     * @param second The second date to compare.\n     * @returns 0 if the dates are equal, a number less than 0 if the first date is earlier,\n     *     a number greater than 0 if the first date is later.\n     */\n    compareDate(first, second) {\n        return this.getYear(first) - this.getYear(second) ||\n            this.getMonth(first) - this.getMonth(second) ||\n            this.getDate(first) - this.getDate(second);\n    }\n    /**\n     * Compares two dates.\n     * @param first The first date to compare.\n     * @param second The second date to compare.\n     * @returns 0 if the dates are equal, a number less than 0 if the first date is earlier,\n     *     a number greater than 0 if the first date is later.\n     */\n    compareDateTime(first, second) {\n        return this.getYear(first) - this.getYear(second) ||\n            this.getMonth(first) - this.getMonth(second) ||\n            this.getDate(first) - this.getDate(second) ||\n            this.getHours(first) - this.getHours(second) ||\n            this.getMinutes(first) - this.getMinutes(second) ||\n            this.getSeconds(first) - this.getSeconds(second) ||\n            this.getMilliseconds(first) - this.getMilliseconds(second);\n    }\n    /**\n     * Checks if two dates are equal.\n     * @param first The first date to check.\n     * @param second The second date to check.\n     * @returns Whether the two dates are equal.\n     *     Null dates are considered equal to other null dates.\n     */\n    sameDate(first, second) {\n        if (first && second) {\n            const firstValid = this.isValid(first);\n            const secondValid = this.isValid(second);\n            if (firstValid && secondValid) {\n                return !this.compareDate(first, second);\n            }\n            return firstValid === secondValid;\n        }\n        return first === second;\n    }\n    /**\n     * Clamp the given date between min and max dates.\n     * @param date The date to clamp.\n     * @param min The minimum value to allow. If null or omitted no min is enforced.\n     * @param max The maximum value to allow. If null or omitted no max is enforced.\n     * @returns `min` if `date` is less than `min`, `max` if date is greater than `max`,\n     *     otherwise `date`.\n     */\n    clampDate(date, min, max) {\n        if (min && this.compareDate(date, min) < 0) {\n            return min;\n        }\n        if (max && this.compareDate(date, max) > 0) {\n            return max;\n        }\n        return date;\n    }\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { DateAdapter, MC_DATE_FORMATS, MC_DATE_LOCALE, MC_DATE_LOCALE_FACTORY };\n//# sourceMappingURL=ptsecurity-cdk-datetime.mjs.map\n","map":{"version":3,"file":"ptsecurity-cdk-datetime.mjs","sources":["../../../packages/cdk/datetime/date-formats.ts","../../../packages/cdk/datetime/date-adapter.ts","../../../packages/cdk/datetime/ptsecurity-cdk-datetime.ts"],"sourcesContent":["import { InjectionToken } from '@angular/core';\n\n\n// tslint:disable-next-line:naming-convention\nexport interface McDateFormats {\n    dateInput: any;\n    monthYearLabel: any;\n    dateA11yLabel: any;\n    monthYearA11yLabel: any;\n}\n\nexport const MC_DATE_FORMATS = new InjectionToken<McDateFormats>('mc-date-formats');\n","import { inject, InjectionToken, LOCALE_ID } from '@angular/core';\nimport { Observable, Subject } from 'rxjs';\n\n\n/** InjectionToken for datepicker that can be used to override default locale code. */\nexport const MC_DATE_LOCALE = new InjectionToken<string>('MC_DATE_LOCALE', {\n    providedIn: 'root',\n    factory: MC_DATE_LOCALE_FACTORY\n});\n\n/** @docs-private */\n// tslint:disable-next-line:naming-convention\nexport function MC_DATE_LOCALE_FACTORY(): string {\n    return inject(LOCALE_ID);\n}\n\n// tslint:disable-next-line:naming-convention\nexport interface DateAdapterConfig {\n    variables: { [name: string]: string };\n\n    monthNames: {\n        long: string[];\n        short: {\n            standalone: string[];\n            formatted: string[];\n        };\n        narrow: string[];\n    };\n\n    dayOfWeekNames: {\n        long: string[];\n        short: string[];\n        narrow: string[];\n    };\n\n    firstDayOfWeek: number;\n}\n\n\n/** Adapts type `D` to be usable as a date by cdk-based components that work with dates. */\n// tslint:disable-next-line:naming-convention\nexport abstract class DateAdapter<D> {\n    config: DateAdapterConfig;\n\n    /** The locale to use for all dates. */\n    protected locale: any;\n\n    /** A stream that emits when the locale changes. */\n    get localeChanges(): Observable<any> {\n        return this._localeChanges;\n    }\n\n    private _localeChanges = new Subject<void>();\n\n    /**\n     * Gets the year component of the given date.\n     * @param date The date to extract the year from.\n     * @returns The year component.\n     */\n    abstract getYear(date: D): number;\n\n    /**\n     * Gets the month component of the given date.\n     * @param date The date to extract the month from.\n     * @returns The month component (0-indexed, 0 = January).\n     */\n    abstract getMonth(date: D): number;\n\n    /**\n     * Gets the date of the month component of the given date.\n     * @param date The date to extract the date of the month from.\n     * @returns The month component (1-indexed, 1 = first of month).\n     */\n    abstract getDate(date: D): number;\n\n    /**\n     * Gets the day of the week component of the given date.\n     * @param date The date to extract the day of the week from.\n     * @returns The month component (0-indexed, 0 = Sunday).\n     */\n    abstract getDayOfWeek(date: D): number;\n\n    /**\n     * Gets the hours component of the given date.\n     * @param date The date to extract from.\n     * @returns The hours component in 24h format.\n     */\n    abstract getHours(date: D): number;\n\n    /**\n     * Gets the minutes component of the given date.\n     * @param date The date to extract from.\n     * @returns The minutes component\n     */\n    abstract getMinutes(date: D): number;\n\n    /**\n     * Gets the seconds component of the given date.\n     * @param date The date to extract from.\n     * @returns The seconds component\n     */\n    abstract getSeconds(date: D): number;\n\n    /**\n     * Gets the milliseconds component of the given date.\n     * @param date The date to extract from.\n     * @returns The milliseconds component\n     */\n    abstract getMilliseconds(date: D): number;\n\n    /**\n     * Gets returns the number of milliseconds since the Unix Epoch of the given date.\n     * @param date The date to extract from.\n     * @returns The milliseconds\n     */\n    abstract getTime(date: D): number;\n\n    /**\n     * Gets a list of names for the months.\n     * @param style The naming style (e.g. long = 'January', short = 'Jan', narrow = 'J').\n     * @returns An ordered list of all month names, starting with January.\n     */\n    abstract getMonthNames(style: 'long' | 'short' | 'narrow'): string[];\n\n    /**\n     * Gets a list of names for the dates of the month.\n     * @returns An ordered list of all date of the month names, starting with '1'.\n     */\n    abstract getDateNames(): string[];\n\n    /**\n     * Gets a list of names for the days of the week.\n     * @param style The naming style (e.g. long = 'Sunday', short = 'Sun', narrow = 'S').\n     * @returns An ordered list of all weekday names, starting with Sunday.\n     */\n    abstract getDayOfWeekNames(style: 'long' | 'short' | 'narrow'): string[];\n\n    /**\n     * Gets the name for the year of the given date.\n     * @param date The date to get the year name for.\n     * @returns The name of the given year (e.g. '2017').\n     */\n    abstract getYearName(date: D): string;\n\n    /**\n     * Gets the first day of the week.\n     * @returns The first day of the week (0-indexed, 0 = Sunday).\n     */\n    abstract getFirstDayOfWeek(): number;\n\n    /**\n     * Gets the number of days in the month of the given date.\n     * @param date The date whose month should be checked.\n     * @returns The number of days in the month of the given date.\n     */\n    abstract getNumDaysInMonth(date: D): number;\n\n    /**\n     * Clones the given date.\n     * @param date The date to clone\n     * @returns A new date equal to the given date.\n     */\n    abstract clone(date: D): D;\n\n    /**\n     * Creates a date with the given year, month, and date. Does not allow over/under-flow of the\n     * month and date.\n     * @param year The full year of the date. (e.g. 89 means the year 89, not the year 1989).\n     * @param month The month of the date (0-indexed, 0 = January). Must be an integer 0 - 11.\n     * @param date The date of month of the date. Must be an integer 1 - length of the given month.\n     * @returns The new date, or null if invalid.\n     */\n    abstract createDate(year: number, month?: number, date?: number): D;\n\n    /**\n     * Creates a date time with the given year, month, date, hours, minutes, seconds and milliseconds.\n     * Does not allow over/under-flow of the month and date.\n     * @param year The full year of the date. (e.g. 89 means the year 89, not the year 1989).\n     * @param month The month of the date (0-indexed, 0 = January). Must be an integer 0 - 11.\n     * @param date The date of month of the date. Must be an integer 1 - length of the given month.\n     * @param hours The date of month of the date. Must be an integer 1 - length of the given month.\n     * @param minutes The date of month of the date. Must be an integer 1 - length of the given month.\n     * @param seconds The date of month of the date. Must be an integer 1 - length of the given month.\n     * @param milliseconds The date of month of the date. Must be an integer 1 - length of the given month.\n     * @returns The new date, or null if invalid.\n     */\n    abstract createDateTime(\n        year: number, month: number, date: number,\n        hours: number, minutes: number, seconds: number, milliseconds: number\n    ): D;\n\n    /**\n     * Gets today's date.\n     * @returns Today's date.\n     */\n    abstract today(): D;\n\n    /**\n     * Parses a date from a user-provided value.\n     * @param value The value to parse.\n     * @param parseFormat The expected format of the value being parsed\n     *     (type is implementation-dependent).\n     * @returns The parsed date.\n     */\n    abstract parse(value: any, parseFormat: any): D | null;\n\n    /**\n     * Formats a date as a string according to the given format.\n     * @param date The value to format.\n     * @param displayFormat The format to use to display the date as a string.\n     * @returns The formatted date string.\n     */\n    abstract format(date: D, displayFormat: any): string;\n\n    /**\n     * Adds the given number of years to the date. Years are counted as if flipping 12 pages on the\n     * calendar for each year and then finding the closest date in the new month. For example when\n     * adding 1 year to Feb 29, 2016, the resulting date will be Feb 28, 2017.\n     * @param date The date to add years to.\n     * @param years The number of years to add (may be negative).\n     * @returns A new date equal to the given one with the specified number of years added.\n     */\n    abstract addCalendarYears(date: D, years: number): D;\n\n    /**\n     * Adds the given number of months to the date. Months are counted as if flipping a page on the\n     * calendar for each month and then finding the closest date in the new month. For example when\n     * adding 1 month to Jan 31, 2017, the resulting date will be Feb 28, 2017.\n     * @param date The date to add months to.\n     * @param months The number of months to add (may be negative).\n     * @returns A new date equal to the given one with the specified number of months added.\n     */\n    abstract addCalendarMonths(date: D, months: number): D;\n\n    /**\n     * Adds the given number of days to the date. Days are counted as if moving one cell on the\n     * calendar for each day.\n     * @param date The date to add days to.\n     * @param days The number of days to add (may be negative).\n     * @returns A new date equal to the given one with the specified number of days added.\n     */\n    abstract addCalendarDays(date: D, days: number): D;\n\n    /**\n     * Gets the RFC 3339 compatible string (https://tools.ietf.org/html/rfc3339) for the given date.\n     * This method is used to generate date strings that are compatible with native HTML attributes\n     * such as the `min` or `max` attribute of an `<input>`.\n     * @param date The date to get the ISO date string for.\n     * @returns The ISO date string date string.\n     */\n    abstract toIso8601(date: D): string;\n\n    /**\n     * Checks whether the given object is considered a date instance by this DateAdapter.\n     * @param obj The object to check\n     * @returns Whether the object is a date instance.\n     */\n    abstract isDateInstance(obj: any): boolean;\n\n    /**\n     * Checks whether the given date is valid.\n     * @param date The date to check.\n     * @returns Whether the date is valid.\n     */\n    abstract isValid(date: D): boolean;\n\n    /**\n     * Gets date instance that is not valid.\n     * @returns An invalid date.\n     */\n    abstract invalid(): D;\n\n    abstract hasSame(startDate: D, endDate: D, unit): boolean;\n\n    abstract diffNow(date: D, unit): number;\n\n    /**\n     * Attempts to deserialize a value to a valid date object. This is different from parsing in that\n     * deserialize should only accept non-ambiguous, locale-independent formats (e.g. a ISO 8601\n     * string). The default implementation does not allow any deserialization, it simply checks that\n     * the given value is already a valid date object or null. The `<mat-datepicker>` will call this\n     * method on all of it's `@Input()` properties that accept dates. It is therefore possible to\n     * support passing values from your backend directly to these properties by overriding this method\n     * to also deserialize the format used by your backend.\n     * @param value The value to be deserialized into a date object.\n     * @returns The deserialized date object, either a valid date, null if the value can be\n     *     deserialized into a null date (e.g. the empty string), or an invalid date.\n     */\n    deserialize(value: any): D | null {\n        if (value == null || this.isDateInstance(value) && this.isValid(value)) { return value; }\n\n        return this.invalid();\n    }\n\n    /**\n     * Sets the locale used for all dates.\n     * @param locale The new locale.\n     */\n    setLocale(locale: any) {\n        this.locale = locale;\n        this._localeChanges.next();\n    }\n\n    /**\n     * Compares two dates.\n     * @param first The first date to compare.\n     * @param second The second date to compare.\n     * @returns 0 if the dates are equal, a number less than 0 if the first date is earlier,\n     *     a number greater than 0 if the first date is later.\n     */\n    compareDate(first: D, second: D): number {\n        return this.getYear(first) - this.getYear(second) ||\n            this.getMonth(first) - this.getMonth(second) ||\n            this.getDate(first) - this.getDate(second);\n    }\n\n    /**\n     * Compares two dates.\n     * @param first The first date to compare.\n     * @param second The second date to compare.\n     * @returns 0 if the dates are equal, a number less than 0 if the first date is earlier,\n     *     a number greater than 0 if the first date is later.\n     */\n    compareDateTime(first: D, second: D): number {\n        return this.getYear(first) - this.getYear(second) ||\n            this.getMonth(first) - this.getMonth(second) ||\n            this.getDate(first) - this.getDate(second) ||\n            this.getHours(first) - this.getHours(second) ||\n            this.getMinutes(first) - this.getMinutes(second) ||\n            this.getSeconds(first) - this.getSeconds(second) ||\n            this.getMilliseconds(first) - this.getMilliseconds(second);\n    }\n\n    /**\n     * Checks if two dates are equal.\n     * @param first The first date to check.\n     * @param second The second date to check.\n     * @returns Whether the two dates are equal.\n     *     Null dates are considered equal to other null dates.\n     */\n    sameDate(first: D | null, second: D | null): boolean {\n        if (first && second) {\n            const firstValid = this.isValid(first);\n            const secondValid = this.isValid(second);\n\n            if (firstValid && secondValid) {\n                return !this.compareDate(first, second);\n            }\n\n            return firstValid === secondValid;\n        }\n\n        return first === second;\n    }\n\n    /**\n     * Clamp the given date between min and max dates.\n     * @param date The date to clamp.\n     * @param min The minimum value to allow. If null or omitted no min is enforced.\n     * @param max The maximum value to allow. If null or omitted no max is enforced.\n     * @returns `min` if `date` is less than `min`, `max` if date is greater than `max`,\n     *     otherwise `date`.\n     */\n    clampDate(date: D, min?: D | null, max?: D | null): D {\n        if (min && this.compareDate(date, min) < 0) { return min; }\n\n        if (max && this.compareDate(date, max) > 0) { return max; }\n\n        return date;\n    }\n}\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],"names":[],"mappings":"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"}}}